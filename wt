#!/usr/bin/env zsh
set -euo pipefail

readonly VERSION="4.0.0"

# Defaults (can be overridden by config file or env vars)
HERD_ROOT="${HERD_ROOT:-$HOME/Herd}"
HERD_CONFIG="${HERD_CONFIG:-$HOME/Library/Application Support/Herd/config}"
DEFAULT_BASE="${WT_BASE_DEFAULT:-origin/staging}"
DEFAULT_EDITOR="${WT_EDITOR:-cursor}"

# URL generation defaults
WT_URL_SUBDOMAIN="${WT_URL_SUBDOMAIN:-}"  # Optional subdomain prefix (e.g., "api" -> api.feature-name.test)

# Database defaults
DB_HOST="${WT_DB_HOST:-127.0.0.1}"
DB_USER="${WT_DB_USER:-root}"
DB_PASSWORD="${WT_DB_PASSWORD:-}"
DB_CREATE="${WT_DB_CREATE:-true}"
DB_BACKUP_DIR="${WT_DB_BACKUP_DIR:-$HOME/Code/Project Support/Worktree/Database/Backup}"
DB_BACKUP="${WT_DB_BACKUP:-true}"

# Hooks directory (for custom post-add scripts, etc.)
WT_HOOKS_DIR="${WT_HOOKS_DIR:-$HOME/.wt/hooks}"

# Templates directory (for worktree setup templates)
WT_TEMPLATES_DIR="${WT_TEMPLATES_DIR:-$HOME/.wt/templates}"

# Active template (set via --template flag)
WT_TEMPLATE=""

# Global flags
QUIET=false
FORCE=false
JSON_OUTPUT=false
PRETTY_JSON=false
DRY_RUN=false
DELETE_BRANCH=false
DROP_DB=false
NO_BACKUP=false
INTERACTIVE=false

# Parallel operations config
WT_MAX_PARALLEL="${WT_MAX_PARALLEL:-4}"

# Protected branches (cannot be removed without --force)
PROTECTED_BRANCHES="${WT_PROTECTED_BRANCHES:-staging main master}"

# Colour defaults (will be set properly by setup_colors)
C_RESET="" C_BOLD="" C_DIM="" C_RED="" C_GREEN="" C_YELLOW="" C_BLUE="" C_MAGENTA="" C_CYAN=""

# 01-core.sh - Configuration loading, colours, output helpers

# Load config file safely (key=value parsing, not source)
load_config() {
  # Safe config parser - only allows whitelisted variables
  parse_config_file() {
    local file="$1"
    [[ -f "$file" ]] || return 0

    while IFS='=' read -r key value || [[ -n "$key" ]]; do
      # Skip comments and empty lines
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

      # Trim whitespace from key
      key="${key#"${key%%[![:space:]]*}"}"
      key="${key%"${key##*[![:space:]]}"}"

      # Remove quotes and trailing comments from value
      value="${value#\"}"
      value="${value%\"}"
      value="${value#\'}"
      value="${value%\'}"
      value="${value%%#*}"
      value="${value%"${value##*[![:space:]]}"}"

      # Only set whitelisted variables (security)
      case "$key" in
        HERD_ROOT) HERD_ROOT="$value" ;;
        HERD_CONFIG) HERD_CONFIG="$value" ;;
        DEFAULT_BASE) DEFAULT_BASE="$value" ;;
        DEFAULT_EDITOR) DEFAULT_EDITOR="$value" ;;
        WT_URL_SUBDOMAIN) WT_URL_SUBDOMAIN="$value" ;;
        WT_MAX_PARALLEL) WT_MAX_PARALLEL="$value" ;;
        DB_HOST) DB_HOST="$value" ;;
        DB_USER) DB_USER="$value" ;;
        DB_PASSWORD) DB_PASSWORD="$value" ;;
        DB_CREATE) DB_CREATE="$value" ;;
        DB_BACKUP_DIR) DB_BACKUP_DIR="$value" ;;
        DB_BACKUP) DB_BACKUP="$value" ;;
        WT_HOOKS_DIR) WT_HOOKS_DIR="$value" ;;
        WT_TEMPLATES_DIR) WT_TEMPLATES_DIR="$value" ;;
        PROTECTED_BRANCHES) PROTECTED_BRANCHES="$value" ;;
      esac
    done < "$file"
  }

  local config_file="${WT_CONFIG:-$HOME/.wtrc}"
  parse_config_file "$config_file"
  # Also check HERD_ROOT/.wtconfig
  parse_config_file "$HERD_ROOT/.wtconfig"
}

# Load repo-specific config from bare repo directory
# Called by commands that need repo-specific settings (add, sync, clone)
load_repo_config() {
  local git_dir="$1"
  local repo_config="$git_dir/.wtconfig"

  [[ -f "$repo_config" ]] || return 0

  # Re-use the parse_config_file function from load_config
  while IFS='=' read -r key value || [[ -n "$key" ]]; do
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"
    value="${value#\"}"
    value="${value%\"}"
    value="${value#\'}"
    value="${value%\'}"
    value="${value%%#*}"
    value="${value%"${value##*[![:space:]]}"}"

    case "$key" in
      DEFAULT_BASE) DEFAULT_BASE="$value" ;;
      WT_URL_SUBDOMAIN) WT_URL_SUBDOMAIN="$value" ;;
      PROTECTED_BRANCHES) PROTECTED_BRANCHES="$value" ;;
    esac
  done < "$repo_config"
}

# Colours (disabled if not a tty or JSON output)
setup_colors() {
  if [[ -t 1 ]] && [[ "$JSON_OUTPUT" == false ]]; then
    C_RESET=$'\033[0m'
    C_BOLD=$'\033[1m'
    C_DIM=$'\033[2m'
    C_RED=$'\033[31m'
    C_GREEN=$'\033[32m'
    C_YELLOW=$'\033[33m'
    C_BLUE=$'\033[34m'
    C_MAGENTA=$'\033[35m'
    C_CYAN=$'\033[36m'
  fi
}

die()  { print -r -- "${C_RED}âœ– ERROR:${C_RESET} $*" >&2; exit 1; }
info() { [[ "$QUIET" == true ]] || print -r -- "${C_BLUE}â†’${C_RESET} $*"; }
ok()   { [[ "$QUIET" == true ]] || print -r -- "${C_GREEN}âœ”${C_RESET} $*"; }
warn() { print -r -- "${C_YELLOW}âš ${C_RESET} $*"; }
dim()  { [[ "$QUIET" == true ]] || print -r -- "${C_DIM}$*${C_RESET}"; }

# Error helper for worktree not found
die_wt_not_found() {
  local repo="$1" wt_path="$2"
  print -r -- "${C_RED}âœ– ERROR:${C_RESET} Worktree not found at ${C_CYAN}$wt_path${C_RESET}" >&2
  print -r -- "" >&2
  print -r -- "  ${C_DIM}To see available worktrees, run:${C_RESET}" >&2
  print -r -- "    wt ls $repo" >&2
  print -r -- "" >&2
  exit 1
}

# macOS notification
notify() {
  local title="$1" message="$2"
  if command -v osascript >/dev/null 2>&1; then
    osascript -e "display notification \"$message\" with title \"$title\"" 2>/dev/null || true
  fi
}

# Confirmation helper
confirm() {
  local msg="$1"
  [[ "$FORCE" == true ]] && return 0

  print -n "${C_YELLOW}$msg [y/N]${C_RESET} "
  local response
  read -r response
  [[ "$response" =~ ^[Yy]$ ]]
}

# 02-validation.sh - Input validation and security checks

# Check if branch is protected
is_protected_branch() {
  local branch="$1"
  local protected
  for protected in ${=PROTECTED_BRANCHES}; do
    [[ "$branch" == "$protected" ]] && return 0
  done
  return 1
}

# Config validation
validate_config() {
  local warnings=0

  # Check HERD_ROOT exists
  if [[ ! -d "$HERD_ROOT" ]]; then
    warn "HERD_ROOT does not exist: $HERD_ROOT"
    warnings=$((warnings + 1))
  fi

  # Check for required tools (only warn, don't fail)
  if ! command -v git >/dev/null 2>&1; then
    warn "git not found in PATH"
    warnings=$((warnings + 1))
  fi

  return $warnings
}

# Common validation helper for identifiers (repos, branches, templates)
# Usage: validate_identifier <value> <type> <allowed_chars_regex> [extra_checks]
# Returns 0 on success, calls die on failure
validate_identifier_common() {
  local input="$1" type="$2"

  # Block empty or whitespace-only
  if [[ -z "$input" || "$input" =~ ^[[:space:]]*$ ]]; then
    die "Invalid $type: name cannot be empty"
  fi

  # Block path traversal
  if [[ "$input" == *".."* ]]; then
    die "Invalid $type: '$input' (path traversal not allowed)"
  fi

  # Block names starting with dash (flag injection)
  if [[ "$input" == -* ]]; then
    die "Invalid $type: '$input' (cannot start with dash)"
  fi
}

validate_name() {
  local input="$1" type="$2"

  validate_identifier_common "$input" "$type"

  # Block absolute paths
  if [[ "$input" == /* ]]; then
    die "Invalid $type name: '$input' (absolute paths not allowed)"
  fi

  # Block hidden path segments
  if [[ "$input" == *"/."* || "$input" == *"/./"* ]]; then
    die "Invalid $type name: '$input' (path traversal not allowed)"
  fi

  # Block reserved git references
  if [[ "$type" == "branch" && "$input" =~ ^(HEAD|refs/|@).*$ ]]; then
    die "Invalid $type name: '$input' (reserved git reference)"
  fi

  # Allow alphanumeric, dash, underscore, forward slash, dot
  if [[ ! "$input" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
    die "Invalid $type name: '$input' (only alphanumeric, dash, underscore, slash, dot allowed)"
  fi

  # Block empty segments in paths
  if [[ "$input" =~ // || "$input" =~ /$ ]]; then
    die "Invalid $type name: '$input' (malformed path)"
  fi
}

# Validate branch name against configured pattern
# Usage: validate_branch_pattern <branch_name>
# Uses BRANCH_PATTERN from config (optional)
validate_branch_pattern() {
  local branch="$1"

  # Skip if no pattern configured
  [[ -z "${BRANCH_PATTERN:-}" ]] && return 0

  # Check against pattern
  if [[ ! "$branch" =~ $BRANCH_PATTERN ]]; then
    local suggestion=""

    # Try to suggest a fix
    local clean_branch="${branch//[^a-z0-9\/\-]/-}"  # Replace invalid chars
    clean_branch="${clean_branch:l}"  # Lowercase
    clean_branch="${clean_branch//--/-}"  # Remove double dashes

    # Try common prefixes
    if [[ ! "$branch" =~ ^(feature|bugfix|hotfix|release)/ ]]; then
      suggestion="feature/${clean_branch##*/}"
    else
      suggestion="$clean_branch"
    fi

    local error_msg="Branch name '${C_RED}$branch${C_RESET}' doesn't match required pattern"
    error_msg+="\n\n${C_DIM}Pattern:${C_RESET} $BRANCH_PATTERN"
    error_msg+="\n${C_DIM}Example:${C_RESET} feature/my-feature, bugfix/fix-login"

    if [[ "$suggestion" != "$branch" ]]; then
      error_msg+="\n\n${C_YELLOW}Suggestion:${C_RESET} $suggestion"
    fi

    error_msg+="\n\n${C_DIM}Use --force to bypass this check${C_RESET}"

    if [[ "${FORCE:-false}" != true ]]; then
      die "$error_msg"
    else
      warn "Branch name doesn't match pattern (bypassed with --force)"
    fi
  fi
}

# Auto-fix common branch name issues
# Usage: normalize_branch_name <branch_name>
normalize_branch_name() {
  local branch="$1"

  # Replace spaces with dashes
  branch="${branch// /-}"

  # Lowercase
  branch="${branch:l}"

  # Remove consecutive dashes
  while [[ "$branch" == *"--"* ]]; do
    branch="${branch//--/-}"
  done

  # Remove leading/trailing dashes from segments
  branch="${branch#-}"
  branch="${branch%-}"

  print -r -- "$branch"
}

# 03-paths.sh - Path resolution, worktree detection, URL generation

sed_inplace() {
  local pattern="$1" file="$2"
  if sed --version 2>&1 | grep -q GNU; then
    sed -i "$pattern" "$file"
  else
    sed -i '' "$pattern" "$file"
  fi
}

slugify_branch() {
  local b="$1"
  print -r -- "${b//\//-}"
}

# Extract feature name from branch (strips prefixes like feature/, bugfix/, etc.)
# e.g., "feature/sms-unsubscribe" -> "sms-unsubscribe"
# e.g., "feature/dh/uat/build-test" -> "build-test" (takes last segment)
# e.g., "staging" -> "staging" (unchanged if no prefix)
extract_feature_name() {
  local branch="$1"
  local result="$branch"

  # If branch contains a slash, extract the last segment
  if [[ "$branch" == */* ]]; then
    result="${branch##*/}"
  fi

  print -r -- "$result"
}

# Check if worktree directory name matches the branch it's on
# Returns: "ok", "skip", or "mismatch|expected_slug" (pipe-separated for mismatch)
check_branch_directory_match() {
  local wt_path="$1"
  local actual_branch="$2"
  local repo="$3"

  # Skip bare repo and main worktree (e.g., scooda for staging)
  local folder="${wt_path:t}"
  if [[ "$folder" != *"--"* ]]; then
    print -r -- "skip"
    return 0
  fi

  # Extract the slug from directory name (part after repo--)
  local dir_slug="${folder#*--}"

  # Slugify the actual branch
  local branch_slug; branch_slug="$(slugify_branch "$actual_branch")"

  if [[ "$dir_slug" != "$branch_slug" ]]; then
    print -r -- "mismatch|$branch_slug"
  else
    print -r -- "ok"
  fi
}

# Look up actual worktree path from git by branch name
# Returns empty string if not found
lookup_wt_path() {
  local repo="$1"
  local branch="$2"
  local git_dir; git_dir="$(git_dir_for "$repo")"

  [[ -d "$git_dir" ]] || return 0

  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || return 0

  local path="" current_branch="" line=""
  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ "$current_branch" == "$branch" && -n "$path" ]]; then
        print -r -- "$path"
        return 0
      fi
      path=""
      current_branch=""
      continue
    fi
    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && current_branch="${line#branch refs/heads/}"
  done <<< "$out"

  # Handle last entry (no trailing blank line)
  if [[ "$current_branch" == "$branch" && -n "$path" ]]; then
    print -r -- "$path"
    return 0
  fi

  return 0
}

# Get worktree path - tries lookup first, falls back to computed path
resolve_wt_path() {
  local repo="$1"
  local branch="$2"

  # First try to look up actual path from git
  local actual_path; actual_path="$(lookup_wt_path "$repo" "$branch")"
  if [[ -n "$actual_path" ]]; then
    print -r -- "$actual_path"
    return 0
  fi

  # Fall back to computed path (for new worktrees)
  wt_path_for "$repo" "$branch"
}

# Auto-detect repo and branch from current directory
# Sets DETECTED_REPO and DETECTED_BRANCH globals
# Returns 0 if detected, 1 if not in a worktree
detect_current_worktree() {
  DETECTED_REPO=""
  DETECTED_BRANCH=""

  # Check if we're in a git directory
  local git_dir; git_dir="$(git rev-parse --git-dir 2>/dev/null)" || return 1

  # Get the worktree root
  local wt_root; wt_root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1

  # Check if the worktree is under HERD_ROOT
  [[ "$wt_root" == "$HERD_ROOT"/* ]] || return 1

  # Get the folder name
  local folder="${wt_root:t}"

  # Try to find the bare repo by checking the git-dir path
  # For worktrees, git-dir is like: /path/to/repo.git/worktrees/worktree-name
  if [[ "$git_dir" == *"/worktrees/"* ]]; then
    # Extract bare repo path
    local bare_repo="${git_dir%/worktrees/*}"
    DETECTED_REPO="${${bare_repo:t}%.git}"
  elif [[ -d "$HERD_ROOT/${folder}.git" ]]; then
    # This is a main worktree (like staging) - folder name matches repo
    DETECTED_REPO="$folder"
  else
    # Try to extract repo from folder name (repo--slug pattern)
    if [[ "$folder" == *"--"* ]]; then
      DETECTED_REPO="${folder%%--*}"
    else
      return 1
    fi
  fi

  # Verify the bare repo exists
  [[ -d "$HERD_ROOT/${DETECTED_REPO}.git" ]] || return 1

  # Get the current branch
  DETECTED_BRANCH="$(git branch --show-current 2>/dev/null)" || return 1
  [[ -n "$DETECTED_BRANCH" ]] || return 1

  return 0
}

# Helper to require repo argument, with auto-detection fallback
require_repo() {
  local repo="$1"
  if [[ -z "$repo" ]]; then
    if detect_current_worktree; then
      print -r -- "$DETECTED_REPO"
      return 0
    fi
    return 1
  fi
  print -r -- "$repo"
}

# Helper to require repo and branch, with auto-detection fallback
require_repo_branch() {
  local repo="$1"
  local branch="$2"

  if [[ -z "$repo" ]]; then
    if detect_current_worktree; then
      print -r -- "$DETECTED_REPO $DETECTED_BRANCH"
      return 0
    fi
    return 1
  fi

  if [[ -z "$branch" ]]; then
    # Repo provided but no branch - use fzf or fail
    return 1
  fi

  print -r -- "$repo $branch"
}

git_dir_for() {
  local repo="$1"
  print -r -- "$HERD_ROOT/${repo}.git"
}

wt_path_for() {
  local repo="$1"
  local branch="$2"
  local slug; slug="$(slugify_branch "$branch")"
  print -r -- "$HERD_ROOT/${repo}--${slug}"
}

url_for() {
  local repo="$1"
  local branch="$2"
  local slug; slug="$(slugify_branch "$branch")"
  local site_name="${repo}--${slug}"

  # Build URL: [subdomain.]site-name.test
  # Site name matches the directory name used by Herd
  if [[ -n "$WT_URL_SUBDOMAIN" ]]; then
    print -r -- "https://${WT_URL_SUBDOMAIN}.${site_name}.test"
  else
    print -r -- "https://${site_name}.test"
  fi
}

# 04-git.sh - Git operations and repository helpers

ensure_bare_repo() {
  local git_dir="$1"
  [[ -d "$git_dir" ]] || die "Bare repo not found at $git_dir"
}

# List all repos in HERD_ROOT
list_repos() {
  for dir in "$HERD_ROOT"/*.git(N); do
    [[ -d "$dir" ]] && print -r -- "${${dir:t}%.git}"
  done
}

# List all worktree branches for a repo
list_worktree_branches() {
  local repo="$1"
  local git_dir; git_dir="$(git_dir_for "$repo")"
  [[ -d "$git_dir" ]] || return 0

  git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null | \
    grep '^branch refs/heads/' | \
    sed 's|^branch refs/heads/||'
}

# Interactive branch selection with fzf
select_branch_fzf() {
  local repo="$1" prompt="${2:-Select branch}"
  local git_dir; git_dir="$(git_dir_for "$repo")"

  if ! command -v fzf >/dev/null 2>&1; then
    die "fzf not installed. Install with: brew install fzf"
  fi

  local branches; branches="$(list_worktree_branches "$repo")"
  [[ -n "$branches" ]] || die "No worktrees found for $repo"

  print -r -- "$branches" | fzf --prompt="$prompt: " --height=40% --reverse
}

# Interactive repo selection with fzf
select_repo_fzf() {
  local prompt="${1:-Select repository}"

  if ! command -v fzf >/dev/null 2>&1; then
    die "fzf not installed. Install with: brew install fzf"
  fi

  local repos; repos="$(list_repos)"
  [[ -n "$repos" ]] || die "No repositories found in $HERD_ROOT"

  print -r -- "$repos" | fzf --prompt="$prompt: " --height=40% --reverse
}

# Get ahead/behind counts for a branch
get_ahead_behind() {
  local wt_path="$1" base="${2:-origin/staging}"
  local ahead=0 behind=0

  if git -C "$wt_path" rev-parse --verify "$base" >/dev/null 2>&1; then
    local counts; counts="$(git -C "$wt_path" rev-list --left-right --count HEAD..."$base" 2>/dev/null)" || counts="0	0"
    ahead="${counts%%	*}"
    behind="${counts##*	}"
  fi

  print -r -- "$ahead $behind"
}

# Check if branch is stale (significantly behind base)
check_stale() {
  local wt_path="$1" base="${2:-origin/staging}" threshold="${3:-50}"
  local counts; counts="$(get_ahead_behind "$wt_path" "$base")"
  local behind="${counts##* }"

  if (( behind > threshold )); then
    warn "Branch is ${C_BOLD}$behind${C_RESET}${C_YELLOW} commits behind ${C_DIM}$base${C_RESET}"
    return 0
  fi
  return 1
}

# Get human-readable age of last commit
# Returns: "1d", "2w", "3mo", "1y" etc.
get_last_commit_age() {
  local wt_path="$1"
  local now epoch_seconds age_seconds age_days

  now="$(date +%s)"
  epoch_seconds="$(git -C "$wt_path" log -1 --format=%ct 2>/dev/null)" || { print -r -- "?"; return 0; }

  # Handle future timestamps (clock skew, timezone issues)
  if (( epoch_seconds > now )); then
    print -r -- "<1h"
    return 0
  fi

  (( age_seconds = now - epoch_seconds ))
  (( age_days = age_seconds / 86400 ))

  if (( age_days == 0 )); then
    local hours=$(( age_seconds / 3600 ))
    if (( hours == 0 )); then
      print -r -- "<1h"
    else
      print -r -- "${hours}h"
    fi
  elif (( age_days < 7 )); then
    print -r -- "${age_days}d"
  elif (( age_days < 30 )); then
    print -r -- "$(( age_days / 7 ))w"
  elif (( age_days < 365 )); then
    print -r -- "$(( age_days / 30 ))mo"
  else
    print -r -- "$(( age_days / 365 ))y"
  fi
}

# Get age in days (for threshold comparison)
get_commit_age_days() {
  local wt_path="$1"
  local now epoch_seconds age_seconds

  now="$(date +%s)"
  epoch_seconds="$(git -C "$wt_path" log -1 --format=%ct 2>/dev/null)" || { print -r -- "0"; return 0; }

  # Handle future timestamps (clock skew, timezone issues)
  if (( epoch_seconds > now )); then
    print -r -- "0"
    return 0
  fi

  (( age_seconds = now - epoch_seconds ))
  print -r -- "$(( age_seconds / 86400 ))"
}

# Check if branch is fully merged into base
is_branch_merged() {
  local wt_path="$1" base="${2:-origin/staging}"
  local branch_head base_head

  branch_head="$(git -C "$wt_path" rev-parse HEAD 2>/dev/null)" || return 1

  # Check if the base branch contains this commit
  if git -C "$wt_path" merge-base --is-ancestor "$branch_head" "$base" 2>/dev/null; then
    return 0
  fi
  return 1
}

# Collect worktrees for a repo into an array
# Usage: collect_worktrees "$git_dir" worktrees_array
collect_worktrees() {
  local git_dir="$1"
  local -n result_array="$2"
  result_array=()

  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || return 0

  local path="" branch="" line=""
  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ -n "$path" && -n "$branch" && "$path" != *.git ]]; then
        result_array+=("$path|$branch")
      fi
      path=""
      branch=""
      continue
    fi
    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
  done <<< "$out"

  # Handle last entry
  if [[ -n "$path" && -n "$branch" && "$path" != *.git ]]; then
    result_array+=("$path|$branch")
  fi
}

# 05-database.sh - Database and Herd operations

db_name_for() {
  local repo="$1"
  local branch="$2"
  local slug; slug="$(slugify_branch "$branch")"
  # Replace dashes with underscores for MySQL compatibility
  local db_name="${repo}__${slug}"
  db_name="${db_name//-/_}"

  # MySQL database name limit is 64 characters
  if (( ${#db_name} > 64 )); then
    # Truncate and add hash suffix for uniqueness
    local hash; hash="$(print -r -- "$slug" | md5 | cut -c1-8)"
    local max_repo_len=$((64 - 11))  # Leave room for __<8-char-hash>
    local truncated_repo="${repo:0:$max_repo_len}"
    db_name="${truncated_repo}__${hash}"
    db_name="${db_name//-/_}"
  fi

  print -r -- "$db_name"
}

create_database() {
  local db_name="$1"

  if [[ "$DB_CREATE" != "true" ]]; then
    dim "  Database creation disabled (WT_DB_CREATE=false)"
    return 0
  fi

  if ! command -v mysql >/dev/null 2>&1; then
    warn "MySQL client not found - skipping database creation"
    dim "  Create manually: CREATE DATABASE \`$db_name\`;"
    return 0
  fi

  local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysql_cmd+=(-p"$DB_PASSWORD")
  fi

  info "Creating database ${C_CYAN}$db_name${C_RESET}"

  if "${mysql_cmd[@]}" -e "CREATE DATABASE IF NOT EXISTS \`$db_name\`;" 2>/dev/null; then
    ok "Database created: $db_name"
    return 0
  else
    warn "Could not create database - check MySQL connection"
    dim "  Create manually: CREATE DATABASE \`$db_name\`;"
    return 1
  fi
}

backup_database() {
  local db_name="$1"
  local repo="$2"

  if [[ "$DB_BACKUP" != "true" ]]; then
    dim "  Database backup disabled (WT_DB_BACKUP=false)"
    return 0
  fi

  if ! command -v mysqldump >/dev/null 2>&1; then
    warn "mysqldump not found - skipping database backup"
    return 0
  fi

  # Check if database exists
  local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysql_cmd+=(-p"$DB_PASSWORD")
  fi

  if ! "${mysql_cmd[@]}" -e "USE \`$db_name\`;" 2>/dev/null; then
    dim "  Database $db_name does not exist - skipping backup"
    return 0
  fi

  # Create backup directory
  local backup_dir="$DB_BACKUP_DIR/$repo"
  mkdir -p "$backup_dir" || { warn "Could not create backup directory: $backup_dir"; return 1; }

  # Generate backup filename with timestamp
  local timestamp; timestamp="$(date +%Y%m%d_%H%M%S)"
  local backup_file="$backup_dir/${db_name}_${timestamp}.sql"

  local mysqldump_cmd=(mysqldump -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysqldump_cmd+=(-p"$DB_PASSWORD")
  fi

  info "Backing up database ${C_CYAN}$db_name${C_RESET}"

  if "${mysqldump_cmd[@]}" "$db_name" > "$backup_file" 2>/dev/null; then
    ok "Database backed up: ${C_DIM}$backup_file${C_RESET}"
    return 0
  else
    warn "Could not backup database"
    rm -f "$backup_file" 2>/dev/null
    return 1
  fi
}

drop_database() {
  local db_name="$1"

  if ! command -v mysql >/dev/null 2>&1; then
    warn "MySQL client not found - cannot drop database"
    return 1
  fi

  local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysql_cmd+=(-p"$DB_PASSWORD")
  fi

  # Check if database exists
  if ! "${mysql_cmd[@]}" -e "USE \`$db_name\`;" 2>/dev/null; then
    dim "  Database $db_name does not exist"
    return 0
  fi

  info "Dropping database ${C_CYAN}$db_name${C_RESET}"

  if "${mysql_cmd[@]}" -e "DROP DATABASE \`$db_name\`;" 2>/dev/null; then
    ok "Database dropped: $db_name"
    return 0
  else
    warn "Could not drop database"
    return 1
  fi
}

unsecure_site() {
  local site_name="$1"

  if ! command -v herd >/dev/null 2>&1; then
    return 0
  fi

  info "Unsecuring site ${C_CYAN}$site_name${C_RESET}"
  if herd unsecure "$site_name" >/dev/null 2>&1; then
    ok "Site unsecured"
  else
    # Site might not be secured, which is fine
    dim "  Site was not secured or already unsecured"
  fi

  # Clean up Herd nginx configs and certificates to prevent stale config issues
  cleanup_herd_site "$site_name"
}

# Remove stale Herd nginx configs and certificates for a site
# This prevents nginx from failing to start due to missing certificate files
cleanup_herd_site() {
  local site_name="$1"
  local site_domain="${site_name}.test"
  local nginx_config="$HERD_CONFIG/valet/Nginx/$site_domain"
  local cert_dir="$HERD_CONFIG/valet/Certificates"
  local cleaned=false

  # Remove nginx config if it exists
  if [[ -f "$nginx_config" ]]; then
    /bin/rm -f "$nginx_config" 2>/dev/null && cleaned=true
  fi

  # Remove certificate files (crt, key, csr, conf)
  for ext in crt key csr conf; do
    local cert_file="$cert_dir/${site_domain}.${ext}"
    if [[ -f "$cert_file" ]]; then
      /bin/rm -f "$cert_file" 2>/dev/null && cleaned=true
    fi
  done

  if [[ "$cleaned" == true ]]; then
    dim "  Cleaned up Herd nginx config and certificates"
  fi
}

# 06-hooks.sh - Hook system for extensible worktree setup

# Verify hook file is safe to execute (owned by current user, not world-writable)
verify_hook_security() {
  local hook_file="$1"
  local current_uid; current_uid="$(id -u)"

  # Check ownership (macOS stat format)
  local file_owner; file_owner="$(stat -f %u "$hook_file" 2>/dev/null)"
  if [[ "$file_owner" != "$current_uid" ]]; then
    warn "Hook '$hook_file' is not owned by current user - skipping for security"
    return 1
  fi

  # Check for world-writable (macOS: last digit of octal perms)
  local file_perms; file_perms="$(stat -f %Lp "$hook_file" 2>/dev/null)"
  if [[ "${file_perms: -1}" =~ [2367] ]]; then
    warn "Hook '$hook_file' is world-writable - skipping for security"
    return 1
  fi

  return 0
}

# Run hooks for a given event
# Usage: run_hooks <hook_name> <repo> <branch> <wt_path> <app_url> <db_name>
# Example: run_hooks "post-add" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"
run_hooks() {
  local hook_name="$1"
  local repo="$2"
  local branch="$3"
  local wt_path="$4"
  local app_url="$5"
  local db_name="$6"

  # Check if hooks directory exists
  [[ -d "$WT_HOOKS_DIR" ]] || return 0

  local hook_file="$WT_HOOKS_DIR/$hook_name"

  # Check if hook exists and is executable
  if [[ -x "$hook_file" ]]; then
    # Security check before executing
    if ! verify_hook_security "$hook_file"; then
      return 0
    fi

    info "Running ${C_CYAN}$hook_name${C_RESET} hook..."

    # Export environment variables for the hook
    (
      export WT_REPO="$repo"
      export WT_BRANCH="$branch"
      export WT_PATH="$wt_path"
      export WT_URL="$app_url"
      export WT_DB_NAME="$db_name"
      export WT_HOOK_NAME="$hook_name"
      # Control flags for hooks
      [[ "$NO_BACKUP" == true ]] && export WT_NO_BACKUP="true"
      [[ "$DROP_DB" == true ]] && export WT_DROP_DB="true"

      # Run hook from the worktree directory
      cd "$wt_path" 2>/dev/null || cd "$HOME"

      if "$hook_file"; then
        ok "Hook ${C_CYAN}$hook_name${C_RESET} completed"
      else
        warn "Hook ${C_CYAN}$hook_name${C_RESET} exited with non-zero status"
      fi
    )
  elif [[ -f "$hook_file" ]]; then
    dim "  Hook $hook_name exists but is not executable. Run: chmod +x $hook_file"
  fi

  # Also check for numbered hooks (post-add.d/*.sh pattern for multiple hooks)
  local hooks_d="$WT_HOOKS_DIR/${hook_name}.d"
  if [[ -d "$hooks_d" ]]; then
    # Run global hooks (files only, not directories)
    for hook_script in "$hooks_d"/*(N.x); do
      # Security check before executing
      if ! verify_hook_security "$hook_script"; then
        continue
      fi

      local script_name="${hook_script:t}"
      info "Running ${C_CYAN}$hook_name.d/$script_name${C_RESET}..."

      (
        export WT_REPO="$repo"
        export WT_BRANCH="$branch"
        export WT_PATH="$wt_path"
        export WT_URL="$app_url"
        export WT_DB_NAME="$db_name"
        export WT_HOOK_NAME="$hook_name"
        [[ "$NO_BACKUP" == true ]] && export WT_NO_BACKUP="true"
        [[ "$DROP_DB" == true ]] && export WT_DROP_DB="true"

        cd "$wt_path" 2>/dev/null || cd "$HOME"

        if "$hook_script"; then
          ok "  $script_name completed"
        else
          warn "  $script_name exited with non-zero status"
        fi
      )
    done

    # Run repo-specific hooks (from subdirectory matching repo name)
    local repo_hooks_d="$hooks_d/$repo"
    if [[ -d "$repo_hooks_d" ]]; then
      for hook_script in "$repo_hooks_d"/*(N.x); do
        # Security check before executing
        if ! verify_hook_security "$hook_script"; then
          continue
        fi

        local script_name="${hook_script:t}"
        info "Running ${C_CYAN}$hook_name.d/$repo/$script_name${C_RESET}..."

        (
          export WT_REPO="$repo"
          export WT_BRANCH="$branch"
          export WT_PATH="$wt_path"
          export WT_URL="$app_url"
          export WT_DB_NAME="$db_name"
          export WT_HOOK_NAME="$hook_name"
          [[ "$NO_BACKUP" == true ]] && export WT_NO_BACKUP="true"
          [[ "$DROP_DB" == true ]] && export WT_DROP_DB="true"

          cd "$wt_path" 2>/dev/null || cd "$HOME"

          if "$hook_script"; then
            ok "  $repo/$script_name completed"
          else
            warn "  $repo/$script_name exited with non-zero status"
          fi
        )
      done
    fi
  fi

  return 0
}

# 07-templates.sh - Template loading and listing

# Validate template name (security: prevent path traversal)
validate_template_name() {
  local name="$1"

  validate_identifier_common "$name" "template"

  # Block slashes and backslashes (templates are single files, no paths)
  if [[ "$name" == *"/"* || "$name" == *"\\"* ]]; then
    die "Invalid template name: '$name' (path separators not allowed)"
  fi

  # Only allow alphanumeric, dash, underscore (stricter than repo/branch names)
  if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    die "Invalid template name: '$name' (only alphanumeric, dash, underscore allowed)"
  fi
}

# Extract TEMPLATE_DESC from a template file
# Usage: extract_template_desc "/path/to/template.conf"
extract_template_desc() {
  local file="$1"
  grep '^TEMPLATE_DESC=' "$file" 2>/dev/null | head -1 | cut -d= -f2- | tr -d "\"'"
}

# Find similar names for "did you mean?" suggestions
# Usage: suggest_similar <input> <type> <list_of_options>
# Returns the closest match or empty string
suggest_similar() {
  local input="$1" type="$2"
  shift 2
  local options=("$@")
  local best_match="" best_score=999

  for opt in "${options[@]}"; do
    # Simple similarity: count matching characters at start
    local i=0 score=0
    local input_lower="${input:l}" opt_lower="${opt:l}"

    # Check if input is a prefix
    if [[ "$opt_lower" == "$input_lower"* ]]; then
      score=$((${#opt} - ${#input}))
      if (( score < best_score )); then
        best_score=$score
        best_match="$opt"
      fi
      continue
    fi

    # Check if input is a substring
    if [[ "$opt_lower" == *"$input_lower"* ]]; then
      score=$((${#opt} - ${#input} + 5))
      if (( score < best_score )); then
        best_score=$score
        best_match="$opt"
      fi
      continue
    fi

    # Levenshtein-like: count character differences (simplified)
    local len1=${#input_lower} len2=${#opt_lower}
    local max_len=$(( len1 > len2 ? len1 : len2 ))
    local matching=0
    for (( i=0; i < max_len; i++ )); do
      [[ "${input_lower:$i:1}" == "${opt_lower:$i:1}" ]] && ((matching++))
    done
    score=$((max_len - matching))
    if (( score < best_score && score < max_len / 2 )); then
      best_score=$score
      best_match="$opt"
    fi
  done

  # Only suggest if reasonably close (within half the length)
  if [[ -n "$best_match" && $best_score -lt ${#input} ]]; then
    print -r -- "$best_match"
  fi
}

# Get list of available template names
get_template_names() {
  local templates=()
  if [[ -d "$WT_TEMPLATES_DIR" ]]; then
    for f in "$WT_TEMPLATES_DIR"/*.conf(N); do
      templates+=("${f:t:r}")
    done
  fi
  print -r -- "${templates[@]}"
}

load_template() {
  local template_name="$1"

  # Validate template name first (security: prevent path traversal)
  validate_template_name "$template_name"

  local template_file="$WT_TEMPLATES_DIR/${template_name}.conf"

  # Check if template exists
  if [[ ! -f "$template_file" ]]; then
    local available_templates
    available_templates=($(get_template_names))

    local suggestion=""
    if (( ${#available_templates[@]} > 0 )); then
      suggestion="$(suggest_similar "$template_name" "template" "${available_templates[@]}")"
    fi

    local error_msg="Template not found: ${C_CYAN}$template_name${C_RESET}"
    if [[ -n "$suggestion" ]]; then
      error_msg+="\n\n  ${C_YELLOW}Did you mean:${C_RESET} ${C_GREEN}$suggestion${C_RESET}?"
    fi
    error_msg+="\n\n${C_DIM}Available templates:${C_RESET}\n$(list_templates 2>&1)"
    error_msg+="\n\n${C_DIM}Run 'wt templates' to see all templates${C_RESET}"

    die "$error_msg"
  fi

  # Parse template file (only allow WT_SKIP_* and TEMPLATE_DESC)
  while IFS='=' read -r key value || [[ -n "$key" ]]; do
    # Skip comments and empty lines
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

    # Trim whitespace from key
    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"

    # Remove quotes and trailing comments from value
    value="${value#\"}"
    value="${value%\"}"
    value="${value#\'}"
    value="${value%\'}"
    value="${value%%#*}"
    value="${value%"${value##*[![:space:]]}"}"

    # Only allow WT_SKIP_* variables with true/false values (security)
    case "$key" in
      WT_SKIP_*)
        # Security: Only allow true/false values to prevent command injection
        if [[ "$value" != "true" && "$value" != "false" ]]; then
          warn "Invalid value for $key: '$value' (must be true or false) - skipping"
          continue
        fi
        export "$key"="$value"
        ;;
      TEMPLATE_DESC) ;; # Ignore, used for display only
      *) ;; # Ignore other variables (security)
    esac
  done < "$template_file"

  dim "  Applied template: $template_name"
}

# List available templates
list_templates() {
  local templates_found=false

  if [[ -d "$WT_TEMPLATES_DIR" ]]; then
    for f in "$WT_TEMPLATES_DIR"/*.conf(N); do
      templates_found=true
      local name="${f:t:r}"  # Remove path and .conf extension
      local desc=""

      # Extract TEMPLATE_DESC if present
      desc="$(extract_template_desc "$f")"

      if [[ -n "$desc" ]]; then
        print -r -- "  $name - $desc"
      else
        print -r -- "  $name"
      fi
    done
  fi

  if [[ "$templates_found" != true ]]; then
    print -r -- "  (no templates found)"
    print -r -- ""
    print -r -- "  Create templates in: $WT_TEMPLATES_DIR/"
    print -r -- "  Example: $WT_TEMPLATES_DIR/laravel.conf"
  fi
}

# JSON helper
json_escape() {
  local s="$1"
  s="${s//\\/\\\\}"       # Backslash must be first
  s="${s//\"/\\\"}"       # Double quote
  s="${s//$'\n'/\\n}"     # Newline
  s="${s//$'\t'/\\t}"     # Tab
  s="${s//$'\r'/\\r}"     # Carriage return
  s="${s//$'\f'/\\f}"     # Form feed
  s="${s//$'\b'/\\b}"     # Backspace
  print -r -- "$s"
}

# Pretty-print JSON with colours and indentation
# Usage: format_json "$json_string"
format_json() {
  local json="$1"

  if [[ "$PRETTY_JSON" != true ]]; then
    print -r -- "$json"
    return
  fi

  # Use jq or python3 for proper JSON formatting if available, with fallback to simple approach
  local result="$json"
  local formatted=""

  if command -v jq >/dev/null 2>&1; then
    if formatted="$(print -r -- "$json" | jq . 2>/dev/null)"; then
      result="$formatted"
    fi
  elif command -v python3 >/dev/null 2>&1; then
    if formatted="$(print -r -- "$json" | python3 -m json.tool 2>/dev/null)"; then
      result="$formatted"
    fi
  else
    # Fallback: simple string replacements for basic formatting
    result="${result//\[/$'\n['}"
    result="${result//\{/$'\n  {'}"
    result="${result//\}/$'}\n'}"
    result="${result//\],/$'],\n'}"
    result="${result//\}, /'},\n  '}"
  fi

  # Apply colours if terminal supports it
  if [[ -t 1 ]]; then
    # Colour keys (words before colons)
    result="$(print -r -- "$result" | sed -E "s/\"([^\"]+)\":/\"${C_CYAN}\1${C_RESET}\":/g")"
    # Colour string values
    result="$(print -r -- "$result" | sed -E "s/: \"([^\"]*)\"/: \"${C_GREEN}\1${C_RESET}\"/g")"
    # Colour booleans
    result="${result//: true/: ${C_MAGENTA}true${C_RESET}}"
    result="${result//: false/: ${C_MAGENTA}false${C_RESET}}"
    # Colour numbers (simple approach)
    result="$(print -r -- "$result" | sed -E "s/: ([0-9]+)([,}])/: ${C_YELLOW}\1${C_RESET}\2/g")"
  fi

  print -r -- "$result"
}

# 08-spinner.sh - Progress indicators for long operations

# Spinner characters (Braille pattern for smooth animation)
readonly SPINNER_CHARS='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
readonly SPINNER_DELAY=0.08

# Spinner state
typeset -g SPINNER_PID=""
typeset -g SPINNER_MSG=""

# Start a spinner in the background
# Usage: spinner_start "Installing dependencies..."
spinner_start() {
  local msg="$1"
  SPINNER_MSG="$msg"

  # Don't show spinner if not a TTY or in quiet mode
  [[ -t 1 && "$QUIET" != true ]] || return 0

  # Kill any existing spinner
  spinner_stop 2>/dev/null || true

  (
    local i=0
    local chars_len=${#SPINNER_CHARS}
    while true; do
      local char="${SPINNER_CHARS:$i:1}"
      printf "\r${C_CYAN}%s${C_RESET} %s" "$char" "$msg" >&2
      i=$(( (i + 1) % chars_len ))
      sleep "$SPINNER_DELAY"
    done
  ) &
  SPINNER_PID=$!
  disown $SPINNER_PID 2>/dev/null || true
}

# Stop spinner and show result
# Usage: spinner_stop "ok" or spinner_stop "fail" or spinner_stop "skip"
spinner_stop() {
  local result="${1:-ok}"

  # Kill spinner process
  if [[ -n "$SPINNER_PID" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
  fi

  [[ -t 1 && "$QUIET" != true ]] || return 0

  # Clear spinner line
  printf "\r\033[K" >&2

  # Show result
  case "$result" in
    ok)   print -r -- "${C_GREEN}âœ”${C_RESET} $SPINNER_MSG" ;;
    fail) print -r -- "${C_RED}âœ–${C_RESET} $SPINNER_MSG" ;;
    skip) print -r -- "${C_DIM}â—‹${C_RESET} $SPINNER_MSG ${C_DIM}(skipped)${C_RESET}" ;;
  esac

  SPINNER_MSG=""
}

# Run a command with spinner
# Usage: with_spinner "Installing npm packages" npm install
# Returns the exit code of the command
with_spinner() {
  local msg="$1"
  shift

  spinner_start "$msg"

  local exit_code=0
  if "$@" >/dev/null 2>&1; then
    spinner_stop "ok"
  else
    exit_code=$?
    spinner_stop "fail"
  fi

  return $exit_code
}

# Step progress indicator for multi-step operations
# Usage: step_progress 1 5 "Installing dependencies"
step_progress() {
  local current="$1" total="$2" msg="$3"
  [[ -t 1 && "$QUIET" != true ]] || return 0
  printf "\r${C_DIM}[%d/%d]${C_RESET} %s" "$current" "$total" "$msg" >&2
}

# Clear step progress line
step_complete() {
  [[ -t 1 && "$QUIET" != true ]] || return 0
  printf "\r\033[K" >&2
}

# Ensure spinner is stopped on script exit
trap 'spinner_stop 2>/dev/null' EXIT INT TERM

# 09-parallel.sh - Parallel execution framework

# Report results helper
report_results() {
  local success="$1" failed="$2" total="$3"

  print -r -- ""
  if (( failed == 0 )); then
    ok "All $total operation(s) completed successfully"
  else
    warn "$failed of $total operation(s) failed"
  fi
}

# Run operations in parallel with result collection
# Usage: parallel_run <result_handler> <operations...>
# Each operation is: "label|command"
parallel_run() {
  local result_handler="$1"
  shift
  local operations=("$@")

  local total=${#operations[@]}
  [[ $total -eq 0 ]] && return 0

  # Create temp directory for results
  local tmpdir; tmpdir="$(/usr/bin/mktemp -d)"
  trap "/bin/rm -rf '$tmpdir'" EXIT

  # Job tracking
  local pids=()
  local running=0

  info "Running $total operation(s) in parallel (max $WT_MAX_PARALLEL concurrent)..."

  local i=0
  for op in "${operations[@]}"; do
    i=$((i + 1))
    local label="${op%%|*}"
    local cmd="${op#*|}"

    # Wait if at max parallel
    while (( running >= WT_MAX_PARALLEL )); do
      local new_pids=()
      for pid in "${pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
          new_pids+=("$pid")
        else
          wait "$pid" 2>/dev/null || true
          running=$((running - 1))
        fi
      done
      pids=("${new_pids[@]}")
      (( running >= WT_MAX_PARALLEL )) && sleep 0.1
    done

    # Launch job
    (
      if eval "$cmd" >/dev/null 2>&1; then
        echo "ok|$label" > "$tmpdir/$i"
      else
        echo "fail|$label" > "$tmpdir/$i"
      fi
    ) &
    pids+=($!)
    running=$((running + 1))
  done

  # Wait for remaining jobs
  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  # Collect and report results
  local success=0 failed=0
  i=0
  for op in "${operations[@]}"; do
    i=$((i + 1))
    if [[ -f "$tmpdir/$i" ]]; then
      local result; result="$(<"$tmpdir/$i")"
      local status="${result%%|*}"
      local label="${result#*|}"

      if [[ "$status" == "ok" ]]; then
        ok "  $label"
        success=$((success + 1))
      else
        warn "  $label - failed"
        failed=$((failed + 1))
      fi
    fi
  done

  /bin/rm -rf "$tmpdir"
  trap - EXIT

  # Call result handler
  "$result_handler" "$success" "$failed" "$total"

  return $(( failed > 0 ? 1 : 0 ))
}

# 10-interactive.sh - Interactive worktree creation wizard

# Interactive worktree creation
# Usage: interactive_add [repo]
interactive_add() {
  local initial_repo="${1:-}"

  # Ensure fzf is available
  if ! command -v fzf >/dev/null 2>&1; then
    die "Interactive mode requires fzf. Install with: brew install fzf"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}ðŸŒ³ Interactive Worktree Creation${C_RESET}"
  print -r -- ""

  # Step 1: Repository selection
  local repo="$initial_repo"
  if [[ -z "$repo" ]]; then
    print -r -- "${C_BOLD}Step 1/5:${C_RESET} Select repository"
    local repos; repos="$(list_repos)"
    [[ -n "$repos" ]] || die "No repositories found in $HERD_ROOT"

    repo="$(echo "$repos" | fzf --prompt="Repository: " --height=40% --reverse)"
    [[ -n "$repo" ]] || die "No repository selected"
  fi

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"
  load_repo_config "$git_dir"

  ok "Repository: ${C_CYAN}$repo${C_RESET}"
  print -r -- ""

  # Step 2: Base branch selection
  print -r -- "${C_BOLD}Step 2/5:${C_RESET} Select base branch"

  # Fetch first
  with_spinner "Fetching branches" git --git-dir="$git_dir" fetch --all --prune --quiet

  # Get remote branches for selection
  local branches; branches="$(git --git-dir="$git_dir" branch -r --format='%(refname:short)' 2>/dev/null | grep -v HEAD)"

  local base
  base="$(echo "$branches" | fzf --prompt="Base branch: " --height=40% --reverse --query="origin/staging")"
  [[ -n "$base" ]] || base="$DEFAULT_BASE"

  ok "Base: ${C_DIM}$base${C_RESET}"
  print -r -- ""

  # Step 3: Branch name input with live preview
  print -r -- "${C_BOLD}Step 3/5:${C_RESET} Enter new branch name"
  print -r -- "${C_DIM}  (e.g., feature/my-feature, bugfix/fix-123)${C_RESET}"
  print -r -- ""

  local branch=""
  while [[ -z "$branch" ]]; do
    print -n "  Branch name: "
    read -r branch

    if [[ -z "$branch" ]]; then
      warn "Branch name required"
      continue
    fi

    # Validate
    if ! validate_name "$branch" "branch" 2>/dev/null; then
      warn "Invalid branch name"
      branch=""
      continue
    fi

    # Check if already exists
    if git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch" 2>/dev/null; then
      warn "Branch already exists: $branch"
      branch=""
      continue
    fi
  done

  # Show preview
  local wt_path; wt_path="$(wt_path_for "$repo" "$branch")"
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"

  print -r -- ""
  print -r -- "  ${C_DIM}Preview:${C_RESET}"
  print -r -- "    Path:     ${C_CYAN}$wt_path${C_RESET}"
  print -r -- "    URL:      ${C_BLUE}$app_url${C_RESET}"
  print -r -- "    Database: ${C_CYAN}$db_name${C_RESET}"
  print -r -- ""

  # Step 4: Template selection (optional)
  print -r -- "${C_BOLD}Step 4/5:${C_RESET} Select template ${C_DIM}(optional)${C_RESET}"

  local template=""
  local templates; templates="$(get_template_names)"

  if [[ -n "$templates" ]]; then
    # Add "none" option
    templates="(none)
$templates"

    template="$(echo "$templates" | fzf --prompt="Template: " --height=40% --reverse)"

    if [[ "$template" != "(none)" && -n "$template" ]]; then
      WT_TEMPLATE="$template"
      ok "Template: ${C_CYAN}$template${C_RESET}"
    else
      dim "  No template selected"
    fi
  else
    dim "  No templates available"
  fi
  print -r -- ""

  # Step 5: Confirmation
  print -r -- "${C_BOLD}Step 5/5:${C_RESET} Confirm"
  print -r -- ""
  print -r -- "  ${C_BOLD}Summary:${C_RESET}"
  print -r -- "    Repository: ${C_CYAN}$repo${C_RESET}"
  print -r -- "    Branch:     ${C_MAGENTA}$branch${C_RESET}"
  print -r -- "    Base:       ${C_DIM}$base${C_RESET}"
  print -r -- "    Path:       $wt_path"
  print -r -- "    URL:        ${C_BLUE}$app_url${C_RESET}"
  [[ -n "$WT_TEMPLATE" ]] && print -r -- "    Template:   ${C_CYAN}$WT_TEMPLATE${C_RESET}"
  print -r -- ""

  print -n "  ${C_GREEN}Create worktree? [Y/n]${C_RESET} "
  local response; read -r response

  if [[ "$response" =~ ^[Nn]$ ]]; then
    dim "Aborted"
    return 0
  fi

  print -r -- ""

  # Execute creation (call cmd_add with collected params)
  INTERACTIVE=false  # Disable interactive mode for actual creation
  cmd_add "$repo" "$branch" "$base"
}

# 11-resilience.sh - Retry logic, transactions, disk checks, lock cleanup

# Retry a command with exponential backoff
# Usage: with_retry <max_attempts> <command...>
with_retry() {
  local max_attempts="$1"
  shift

  local attempt=1
  local delay=1

  while (( attempt <= max_attempts )); do
    if "$@"; then
      return 0
    fi

    if (( attempt < max_attempts )); then
      dim "  Attempt $attempt failed, retrying in ${delay}s..."
      sleep "$delay"
      delay=$((delay * 2))
    fi

    attempt=$((attempt + 1))
  done

  return 1
}

# Check for and optionally clean git index locks
# Usage: check_index_locks <git_dir> [--auto-clean]
check_index_locks() {
  local git_dir="$1"
  local auto_clean="${2:-}"
  local locks_found=0

  local worktrees_dir="$git_dir/worktrees"
  [[ -d "$worktrees_dir" ]] || return 0

  for lock_file in "$worktrees_dir"/*/index.lock(N); do
    [[ -f "$lock_file" ]] || continue

    # Check if lock is stale (older than 5 minutes and no git process)
    local lock_age=$(($(date +%s) - $(stat -f %m "$lock_file" 2>/dev/null || echo 0)))
    if (( lock_age > 300 )); then
      if [[ "$auto_clean" == "--auto-clean" ]]; then
        rm -f "$lock_file"
        dim "  Removed stale lock: ${lock_file##*/worktrees/}"
      else
        warn "Stale lock found: ${lock_file##*/worktrees/}"
        locks_found=$((locks_found + 1))
      fi
    fi
  done

  return $locks_found
}

# Check available disk space
# Usage: check_disk_space <path> <min_mb>
check_disk_space() {
  local path="$1"
  local min_mb="${2:-1024}"  # Default 1GB

  local available_kb
  available_kb=$(df -k "$path" 2>/dev/null | tail -1 | awk '{print $4}')
  local available_mb=$((available_kb / 1024))

  if (( available_mb < min_mb )); then
    die "Insufficient disk space: ${available_mb}MB available, ${min_mb}MB required"
  fi
}

# Transaction state
typeset -g WT_TRANSACTION_ACTIVE=false
typeset -g WT_ROLLBACK_STEPS=()

# Start a transaction
transaction_start() {
  WT_TRANSACTION_ACTIVE=true
  WT_ROLLBACK_STEPS=()
  trap 'transaction_rollback' EXIT INT TERM
}

# Register rollback step
transaction_register() {
  WT_ROLLBACK_STEPS+=("$1")
}

# Commit transaction (disable rollback)
transaction_commit() {
  WT_TRANSACTION_ACTIVE=false
  WT_ROLLBACK_STEPS=()
  trap - EXIT INT TERM
}

# Rollback on failure
transaction_rollback() {
  [[ "$WT_TRANSACTION_ACTIVE" == true ]] || return 0

  warn "Rolling back failed operation..."

  # Execute rollback steps in reverse order
  local i
  for ((i=${#WT_ROLLBACK_STEPS[@]}-1; i>=0; i--)); do
    local step="${WT_ROLLBACK_STEPS[$i]}"
    eval "$step" 2>/dev/null || true
  done

  WT_TRANSACTION_ACTIVE=false
}

# lifecycle.sh - Worktree creation and removal commands

cmd_add() {
  local repo="${1:-}"; local branch="${2:-}"; local base="${3:-}"
  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt add <repo> <branch> [base]"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  # Load repo-specific config (may override DEFAULT_BASE)
  load_repo_config "$git_dir"

  # Load template if specified (sets WT_SKIP_* environment variables)
  if [[ -n "$WT_TEMPLATE" ]]; then
    load_template "$WT_TEMPLATE"
  fi

  # Use provided base or default
  [[ -z "$base" ]] && base="$DEFAULT_BASE"

  local wt_path; wt_path="$(wt_path_for "$repo" "$branch")"
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"

  # Dry-run mode - show what would happen without executing
  if [[ "$DRY_RUN" == true ]]; then
    print -r -- ""
    print -r -- "${C_BOLD}Dry Run Preview${C_RESET}"
    print -r -- ""
    print -r -- "${C_BOLD}Worktree Details:${C_RESET}"
    print -r -- "  Repository:  ${C_CYAN}$repo${C_RESET}"
    print -r -- "  Branch:      ${C_MAGENTA}$branch${C_RESET}"
    print -r -- "  Base:        ${C_DIM}$base${C_RESET}"
    print -r -- "  Path:        $wt_path"
    print -r -- "  URL:         ${C_CYAN}$app_url${C_RESET}"
    print -r -- "  Database:    ${C_CYAN}$db_name${C_RESET}"
    print -r -- ""
    if [[ -n "$WT_TEMPLATE" ]]; then
      print -r -- "${C_BOLD}Template:${C_RESET} $WT_TEMPLATE"
      print -r -- "  ${C_DIM}WT_SKIP_DB${C_RESET}=${WT_SKIP_DB:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_COMPOSER${C_RESET}=${WT_SKIP_COMPOSER:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_NPM${C_RESET}=${WT_SKIP_NPM:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_BUILD${C_RESET}=${WT_SKIP_BUILD:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_MIGRATE${C_RESET}=${WT_SKIP_MIGRATE:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_HERD${C_RESET}=${WT_SKIP_HERD:-false}"
      print -r -- ""
    fi
    print -r -- "${C_BOLD}Actions:${C_RESET}"
    print -r -- "  1. Fetch latest branches from remote"
    if git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch" 2>/dev/null; then
      print -r -- "  2. Create worktree from existing branch: $branch"
    else
      print -r -- "  2. Create new branch '$branch' from '$base'"
      print -r -- "  3. Push branch to remote and set up tracking"
    fi
    print -r -- "  4. Run pre-add hooks"
    print -r -- "  5. Run post-add hooks (environment setup)"
    print -r -- ""
    print -r -- "${C_DIM}Run without --dry-run to execute${C_RESET}"
    return 0
  fi

  info "Fetching latest branches..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  # If base is a remote ref (origin/...), explicitly fetch it to ensure we have the latest
  if [[ "$base" == origin/* ]]; then
    local remote_branch="${base#origin/}"
    dim "  Fetching latest: $remote_branch"
    git --git-dir="$git_dir" fetch origin "$remote_branch:refs/remotes/origin/$remote_branch" --force 2>/dev/null || true
  fi

  [[ ! -d "$wt_path" ]] || die "Worktree already exists at ${C_CYAN}$wt_path${C_RESET}"

  # Verify base branch exists when creating new branch
  if ! git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch"; then
    if ! git --git-dir="$git_dir" rev-parse --verify "$base" >/dev/null 2>&1; then
      die "Base branch '$base' not found. Run: git --git-dir=\"$git_dir\" branch -a"
    fi
  fi

  # Run pre-add hooks (can abort by returning non-zero)
  if ! run_hooks "pre-add" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"; then
    die "Pre-add hook failed - aborting"
  fi

  # Setup cleanup trap for failed operations
  local cleanup_needed=true
  trap '[[ "$cleanup_needed" == true ]] && { warn "Cleaning up failed worktree..."; git --git-dir="$git_dir" worktree remove --force "$wt_path" 2>/dev/null; }' EXIT

  if git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch"; then
    info "Creating worktree from existing branch: ${C_MAGENTA}$branch${C_RESET}"
    git --git-dir="$git_dir" worktree add "$wt_path" "$branch"
  else
    info "Creating branch ${C_MAGENTA}$branch${C_RESET} from ${C_DIM}$base${C_RESET}"
    git --git-dir="$git_dir" worktree add --no-track -b "$branch" "$wt_path" "$base"
  fi

  # Set up proper remote tracking for the branch
  info "Setting up remote tracking for ${C_MAGENTA}$branch${C_RESET}"
  if GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git -C "$wt_path" push -u origin "$branch:$branch" 2>/dev/null; then
    ok "Remote branch created and tracking set"
  else
    dim "  Push failed (may need to push manually later): git push -u origin $branch"
  fi

  # Success - disable cleanup trap
  cleanup_needed=false
  trap - EXIT

  # Run post-add hooks
  run_hooks "post-add" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"

  if [[ "$JSON_OUTPUT" == true ]]; then
    print -r -- "{\"path\": \"$(json_escape "$wt_path")\", \"url\": \"$(json_escape "$app_url")\", \"branch\": \"$(json_escape "$branch")\", \"database\": \"$(json_escape "$db_name")\"}"
  else
    print -r -- ""
    ok "${C_BOLD}Worktree ready${C_RESET}"
    print -r -- "   ${C_DIM}Path${C_RESET}  $wt_path"
    print -r -- "   ${C_DIM}URL${C_RESET}   ${C_CYAN}$app_url${C_RESET}"
    print -r -- "   ${C_DIM}DB${C_RESET}    ${C_CYAN}$db_name${C_RESET}"
    print -r -- ""
  fi
}

cmd_rm() {
  local repo="${1:-}"; local branch="${2:-}"

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to remove")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt rm [-f] [--delete-branch] <repo> <branch>"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  local site_name="${wt_path:t}"

  ensure_bare_repo "$git_dir"
  [[ -d "$wt_path" ]] || die "Worktree not found at $wt_path"

  # Branch protection check
  if is_protected_branch "$branch" && [[ "$FORCE" == false ]]; then
    die "Branch '$branch' is protected. Use -f to force removal."
  fi

  # Check for uncommitted changes and confirm (unless --force)
  if [[ "$FORCE" == false ]]; then
    local wt_status; wt_status="$(git -C "$wt_path" status --porcelain 2>/dev/null)" || wt_status=""
    if [[ -n "$wt_status" ]]; then
      local changes; changes="$(print -r -- "$wt_status" | wc -l | tr -d ' ')"
      warn "Worktree has ${C_BOLD}$changes${C_RESET}${C_YELLOW} uncommitted change(s):${C_RESET}"
      git -C "$wt_path" status --short
      print -n "${C_YELLOW}Continue with removal? [y/N]${C_RESET} "
      local response
      read -r response
      [[ "$response" =~ ^[Yy]$ ]] || die "Aborted"
    fi
  fi

  # Run pre-rm hooks
  if ! run_hooks "pre-rm" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"; then
    die "Pre-rm hook failed - aborting"
  fi

  info "Removing worktree ${C_CYAN}$wt_path${C_RESET}"
  if [[ "$FORCE" == true ]]; then
    git --git-dir="$git_dir" worktree remove --force "$wt_path"
  else
    git --git-dir="$git_dir" worktree remove "$wt_path"
  fi

  # Delete branch if requested
  if [[ "$DELETE_BRANCH" == true ]]; then
    info "Deleting branch ${C_MAGENTA}$branch${C_RESET}"
    git --git-dir="$git_dir" branch -D "$branch" 2>/dev/null || warn "Could not delete branch (may not exist locally)"
  fi

  info "Pruning stale worktrees..."
  git --git-dir="$git_dir" worktree prune

  # Run post-rm hooks
  run_hooks "post-rm" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"

  ok "Worktree removed"
  print -r -- ""
}

cmd_clone() {
  local url="${1:-}"; local repo="${2:-}"; local initial_branch="${3:-}"
  [[ -n "$url" ]] || die "Usage: wt clone <url> [repo-name] [branch]"

  # Extract repo name from URL if not provided
  if [[ -z "$repo" ]]; then
    repo="${url##*/}"
    repo="${repo%.git}"
  fi

  validate_name "$repo" "repository"
  [[ -z "$initial_branch" ]] || validate_name "$initial_branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"

  [[ ! -d "$git_dir" ]] || die "Bare repo already exists at $git_dir"

  info "Cloning ${C_CYAN}$url${C_RESET} as bare repo..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git clone --bare "$url" "$git_dir"

  # Configure fetch to get all branches
  /usr/bin/git --git-dir="$git_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

  info "Fetching all branches..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git --git-dir="$git_dir" fetch --all --prune

  print -r -- ""
  ok "Bare repo created at ${C_CYAN}$git_dir${C_RESET}"

  # If specific branch requested, create worktree for it
  if [[ -n "$initial_branch" ]]; then
    print -r -- ""
    if /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/$initial_branch"; then
      info "Creating worktree for ${C_GREEN}$initial_branch${C_RESET}..."
      cmd_add "$repo" "$initial_branch" "origin/$initial_branch"
    else
      local base_branch=""
      if /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/staging"; then
        base_branch="origin/staging"
      elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/main"; then
        base_branch="origin/main"
      elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/master"; then
        base_branch="origin/master"
      else
        die "Branch '$initial_branch' not found on remote and no default base branch available"
      fi
      info "Creating new branch ${C_GREEN}$initial_branch${C_RESET} from $base_branch..."
      cmd_add "$repo" "$initial_branch" "$base_branch"
    fi
  elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/staging"; then
    print -r -- ""
    info "Found staging branch - creating worktree..."
    cmd_add "$repo" "staging" "origin/staging"
  elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/main"; then
    print -r -- ""
    info "Found main branch - creating worktree..."
    cmd_add "$repo" "main" "origin/main"
  elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/master"; then
    print -r -- ""
    info "Found master branch - creating worktree..."
    cmd_add "$repo" "master" "origin/master"
  else
    dim "  Create a worktree with: wt add $repo <branch>"
    print -r -- ""
  fi

  notify "wt clone" "Repository $repo cloned successfully"
}

cmd_fresh() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to refresh")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt fresh [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"

  print -r -- ""
  print -r -- "${C_BOLD}Refreshing ${C_CYAN}$repo${C_RESET} / ${C_MAGENTA}$branch${C_RESET}"
  print -r -- ""

  # Run migrate:fresh --seed (with confirmation unless forced)
  if [[ -f "artisan" ]]; then
    if [[ "$FORCE" == false ]]; then
      warn "This will DROP ALL TABLES in the database!"
      print -n "${C_YELLOW}Continue with migrate:fresh? [y/N]${C_RESET} "
      local response
      read -r response
      if [[ ! "$response" =~ ^[Yy]$ ]]; then
        warn "Skipping migrate:fresh"
        popd >/dev/null
        return 0
      fi
    fi

    info "Running migrate:fresh --seed..."
    if php artisan migrate:fresh --seed; then
      ok "Database refreshed"
    else
      warn "migrate:fresh --seed failed"
    fi
  fi

  # Run npm ci
  if [[ -f "package.json" ]]; then
    info "Running npm ci..."
    if npm ci; then
      ok "npm dependencies installed"
    else
      warn "npm ci failed"
    fi

    info "Running npm run build..."
    if npm run build; then
      ok "Assets built"
    else
      warn "npm run build failed"
    fi
  fi

  popd >/dev/null

  notify "wt fresh" "Completed for $repo / $branch"
  print -r -- ""
  ok "Fresh complete!"
  print -r -- ""
}

# git-ops.sh - Git operation commands

cmd_pull() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to pull")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt pull [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"

  ensure_bare_repo "$git_dir"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  info "Pulling latest changes in ${C_MAGENTA}$branch${C_RESET}..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git -C "$wt_path" pull --rebase
  ok "Pull complete"

  # Run post-pull hooks
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  run_hooks "post-pull" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"
}

cmd_pull_all() {
  local repo="${1:-}"

  # Multi-repo mode
  if [[ "${ALL_REPOS:-false}" == true || -z "$repo" ]]; then
    if [[ "${ALL_REPOS:-false}" == true ]]; then
      info "Pulling all worktrees across all repositories..."
      print -r -- ""
    else
      [[ -n "$repo" ]] || die "Usage: wt pull-all <repo>
       Use --all-repos to pull across all repositories."
    fi

    local total_success=0 total_failed=0
    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      local repo_name="${${git_dir:t}%.git}"
      print -r -- "${C_BOLD}${C_CYAN}$repo_name${C_RESET}"
      _pull_all_for_repo "$repo_name" "$git_dir"
      print -r -- ""
    done

    ok "Pull complete across all repositories"
    return 0
  fi

  validate_name "$repo" "repository"

  local git_dir
  git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  _pull_all_for_repo "$repo" "$git_dir"
}

_pull_all_for_repo() {
  local repo="$1"
  local git_dir="$2"

  dim "  Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet 2>/dev/null || true

  local out
  out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  # Collect worktrees first
  local worktrees=()
  local path="" branch="" line=""

  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ -n "$path" && -n "$branch" && "$path" != "$git_dir" && -d "$path" ]]; then
        worktrees+=("$path|$branch")
      fi
      path=""
      branch=""
      continue
    fi
    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
  done <<< "$out"

  # Handle last entry
  if [[ -n "$path" && -n "$branch" && "$path" != "$git_dir" && -d "$path" ]]; then
    worktrees+=("$path|$branch")
  fi

  # Pull each worktree in parallel
  local total=${#worktrees[@]}
  local count=0 failed=0
  export GIT_SSH_COMMAND="/usr/bin/ssh"

  info "Pulling $total worktree(s) in parallel..."

  # Create temp directory for results
  local tmpdir; tmpdir="$(/usr/bin/mktemp -d)"
  trap "/bin/rm -rf '$tmpdir'" EXIT

  # Launch parallel pulls
  local pids=()
  local idx=0
  for wt_entry in "${worktrees[@]}"; do
    local wt_path="${wt_entry%%|*}"
    local wt_branch="${wt_entry##*|}"

    (
      if /usr/bin/git -C "$wt_path" pull --rebase >/dev/null 2>&1; then
        print -r -- "ok" > "$tmpdir/$idx"
      else
        print -r -- "fail" > "$tmpdir/$idx"
      fi
    ) &
    pids+=($!)
    idx=$((idx + 1))
  done

  # Wait for all to complete
  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  # Collect results
  idx=0
  for wt_entry in "${worktrees[@]}"; do
    local wt_branch="${wt_entry##*|}"
    if [[ -f "$tmpdir/$idx" && "$(/bin/cat "$tmpdir/$idx")" == "ok" ]]; then
      ok "  $wt_branch"
      count=$((count + 1))
    else
      warn "  $wt_branch - failed"
      failed=$((failed + 1))
    fi
    idx=$((idx + 1))
  done

  /bin/rm -rf "$tmpdir"
  trap - EXIT

  print -r -- ""
  ok "Pulled $count worktree(s)"
  (( failed > 0 )) && warn "$failed worktree(s) had issues"

  # Send notification
  if (( failed > 0 )); then
    notify "wt pull-all" "Completed: $count success, $failed failed"
  else
    notify "wt pull-all" "All $count worktrees updated"
  fi
}

cmd_sync() {
  local repo="${1:-}"; local branch="${2:-}"; local base="${3:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to sync")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt sync [<repo> [<branch>]] [base]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  # Load repo-specific config (may override DEFAULT_BASE)
  load_repo_config "$git_dir"

  # Use provided base or default
  [[ -z "$base" ]] && base="$DEFAULT_BASE"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  # Check for uncommitted changes
  if [[ -n "$(/usr/bin/git -C "$wt_path" status --porcelain 2>/dev/null)" ]]; then
    die "Worktree has uncommitted changes. Commit or stash them first."
  fi

  info "Rebasing ${C_MAGENTA}$branch${C_RESET} onto ${C_DIM}$base${C_RESET}..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git -C "$wt_path" rebase "$base"
  ok "Sync complete"

  # Run post-sync hooks
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  run_hooks "post-sync" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"
}

cmd_prune() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt prune <repo>"

  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  info "Pruning stale worktrees..."
  git --git-dir="$git_dir" worktree prune -v

  info "Looking for merged branches..."

  # Get list of branches that have been merged to staging/main
  local merged; merged="$(git --git-dir="$git_dir" branch --merged origin/staging 2>/dev/null | grep -v 'staging\|main\|master' | tr -d ' ')" || merged=""

  if [[ -n "$merged" ]]; then
    print -r -- ""
    warn "The following branches appear to be merged:"
    print -r -- "$merged" | while read -r b; do
      [[ -n "$b" ]] && print -r -- "  ${C_DIM}$b${C_RESET}"
    done
    print -r -- ""

    if [[ "$FORCE" == true ]]; then
      print -r -- "$merged" | while read -r b; do
        [[ -n "$b" ]] && git --git-dir="$git_dir" branch -D "$b" 2>/dev/null && ok "Deleted $b"
      done
    else
      dim "Run with -f to delete merged branches"
    fi
  else
    ok "No merged branches to clean up"
  fi

  ok "Prune complete"
}

cmd_log() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt log [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  print -r -- ""
  print -r -- "${C_BOLD}Recent commits in ${C_MAGENTA}$branch${C_RESET} ${C_DIM}(vs $DEFAULT_BASE)${C_RESET}"
  print -r -- ""

  git -C "$wt_path" log --oneline --graph -n 20 "$DEFAULT_BASE"..HEAD 2>/dev/null || \
    git -C "$wt_path" log --oneline --graph -n 20

  print -r -- ""
}

cmd_diff() {
  local repo="${1:-}"; local branch="${2:-}"; local base="${3:-$DEFAULT_BASE}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to diff")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt diff [<repo> [<branch>]] [base]
       Run from within a worktree to auto-detect, or specify repo/branch.
       Default base: $DEFAULT_BASE"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"

  ensure_bare_repo "$git_dir"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  # Fetch to ensure we have latest base
  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  # Check if base exists
  if ! git -C "$wt_path" rev-parse --verify "$base" >/dev/null 2>&1; then
    die "Base branch '$base' not found. Try: origin/main, origin/staging, or origin/master"
  fi

  # Get stats
  local commits; commits="$(git -C "$wt_path" rev-list --count "$base"..HEAD 2>/dev/null)" || commits="?"
  local files; files="$(git -C "$wt_path" diff --stat "$base"..HEAD 2>/dev/null | tail -1)" || files=""

  print -r -- ""
  print -r -- "${C_BOLD}Diff: ${C_MAGENTA}$branch${C_RESET} ${C_DIM}vs${C_RESET} ${C_CYAN}$base${C_RESET}"
  print -r -- ""
  print -r -- "  ${C_DIM}Commits:${C_RESET} $commits"
  [[ -n "$files" ]] && print -r -- "  ${C_DIM}Summary:${C_RESET} $files"
  print -r -- ""

  # Show the diff
  git -C "$wt_path" diff "$base"..HEAD --stat

  print -r -- ""
  dim "  For full diff: git -C \"$wt_path\" diff $base..HEAD"
  dim "  For patch:     git -C \"$wt_path\" diff $base..HEAD > changes.patch"
  print -r -- ""
}

# navigation.sh - Navigation and editor commands

cmd_code() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to open")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt code [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  local editor="$DEFAULT_EDITOR"

  # Detect available editor
  if ! command -v "$editor" >/dev/null 2>&1; then
    if command -v cursor >/dev/null 2>&1; then
      editor="cursor"
    elif command -v code >/dev/null 2>&1; then
      editor="code"
    else
      die "No editor found. Install VS Code or Cursor, or set WT_EDITOR"
    fi
  fi

  info "Opening in ${C_BOLD}$editor${C_RESET}..."
  "$editor" "$wt_path"
}

cmd_open() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to open")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt open [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  # Get actual worktree path
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  # Read APP_URL from .env file, fall back to folder-based URL
  local url=""
  if [[ -f "$wt_path/.env" ]]; then
    url="$(grep -E '^APP_URL=' "$wt_path/.env" 2>/dev/null | head -1 | cut -d'=' -f2- | sed 's/#.*//' | tr -d '"' | tr -d "'" | tr -d ' ')"
  fi

  # Fallback to folder-based URL if APP_URL not found
  if [[ -z "$url" ]]; then
    local folder="${wt_path:t}"
    url="https://${folder}.test"
    dim "  No APP_URL in .env, using: $url"
  fi

  command -v open >/dev/null 2>&1 || die "'open' command not found (macOS expected)"
  open "$url"
}

cmd_cd() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt cd [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  resolve_wt_path "$repo" "$branch"
}

cmd_switch() {
  local repo="${1:-}"; local branch="${2:-}"

  # Note: No auto-detect for switch - it's meant to switch TO a different worktree

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to switch to")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt switch <repo> [<branch>]"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  # Read APP_URL from .env file, fall back to folder-based URL
  local url=""
  if [[ -f "$wt_path/.env" ]]; then
    url="$(grep -E '^APP_URL=' "$wt_path/.env" 2>/dev/null | head -1 | cut -d'=' -f2- | sed 's/#.*//' | tr -d '"' | tr -d "'" | tr -d ' ')"
  fi
  if [[ -z "$url" ]]; then
    local folder="${wt_path:t}"
    url="https://${folder}.test"
  fi

  # Print path for cd (user can use: cd "$(wt switch ...)")
  print -r -- "$wt_path"

  # Open in editor
  local editor="$DEFAULT_EDITOR"
  if command -v "$editor" >/dev/null 2>&1; then
    "$editor" "$wt_path" &
  fi

  # Open in browser
  if command -v open >/dev/null 2>&1; then
    open "$url" &
  fi
}

cmd_exec() {
  local repo="${1:-}"; local branch="${2:-}"
  shift 2 2>/dev/null || die "Usage: wt exec <repo> <branch> <command...>"
  local cmd=("$@")

  [[ -n "$repo" && -n "$branch" && ${#cmd[@]} -gt 0 ]] || die "Usage: wt exec <repo> <branch> <command...>"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path
  wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die "Worktree not found at $wt_path"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"
  "${cmd[@]}"
  popd >/dev/null
}

# info.sh - Information and status commands

cmd_ls() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt ls [--json] <repo>"

  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  local json_items=()

  display_worktree() {
    local idx="$1" path="$2" branch="$3" head="$4"
    local folder="${path:t}"
    local url
    if [[ -f "$wt_path/.env" ]]; then
      url="$(grep -E '^APP_URL=' "$wt_path/.env" 2>/dev/null | head -1 | cut -d'=' -f2- | sed 's/#.*//' | tr -d '"' | tr -d "'" | tr -d ' ')"
    fi
    [[ -z "$url" ]] && url="https://${folder}.test"
    local sha; sha="$(git -C "$wt_path" rev-parse --short HEAD 2>/dev/null || true)"
    local st; st="$(git -C "$wt_path" status --porcelain 2>/dev/null || true)"
    local state_icon="â—" state_color="$C_GREEN" state_text="clean"
    local dirty=false
    local mismatch=false

    if [[ -n "$st" ]]; then
      local changes; changes="$(print -r -- "$st" | wc -l | tr -d ' ')"
      state_icon="â—"
      state_color="$C_YELLOW"
      state_text="$changes uncommitted"
      dirty=true
    fi

    # Check for branch/directory mismatch
    local match_result="" expected_slug=""
    if [[ -n "$branch" ]]; then
      match_result="$(check_branch_directory_match "$wt_path" "$branch" "$repo")"
      if [[ "$match_result" == mismatch\|* ]]; then
        mismatch=true
        expected_slug="${match_result#mismatch|}"
      fi
    fi

    # Get ahead/behind
    local counts; counts="$(get_ahead_behind "$wt_path" "$DEFAULT_BASE")"
    local ahead="${counts%% *}" behind="${counts##* }"

    if [[ "$JSON_OUTPUT" == true ]]; then
      json_items+=("{\"path\": \"$(json_escape "$wt_path")\", \"branch\": \"$(json_escape "$branch")\", \"sha\": \"$(json_escape "$sha")\", \"url\": \"$(json_escape "$url")\", \"dirty\": $dirty, \"ahead\": $ahead, \"behind\": $behind, \"mismatch\": $mismatch}")
    else
      print -r -- "${C_BOLD}[$idx]${C_RESET} ${C_CYAN}$wt_path${C_RESET}"
      if [[ -n "$branch" ]]; then
        print -r -- "    ${C_DIM}branch${C_RESET}  ${C_MAGENTA}$branch${C_RESET}"
      else
        [[ -n "$head" ]] && print -r -- "    ${C_DIM}head${C_RESET}    ${C_YELLOW}${head:0:12}${C_RESET} (detached)"
      fi
      [[ -n "$sha" ]] && print -r -- "    ${C_DIM}sha${C_RESET}     ${C_DIM}$sha${C_RESET}"
      print -r -- "    ${C_DIM}state${C_RESET}   ${state_color}${state_icon} ${state_text}${C_RESET}"
      if (( ahead > 0 || behind > 0 )); then
        print -r -- "    ${C_DIM}sync${C_RESET}    ${C_GREEN}â†‘$ahead${C_RESET} ${C_RED}â†“$behind${C_RESET}"
      fi
      print -r -- "    ${C_DIM}url${C_RESET}     ${C_BLUE}$url${C_RESET}"
      print -r -- "    ${C_DIM}cd${C_RESET}      ${C_DIM}cd ${(q)path}${C_RESET}"
      if [[ "$mismatch" == true ]]; then
        print -r -- "    ${C_RED}MISMATCH${C_RESET} Directory name doesn't match branch!"
        print -r -- "      ${C_DIM}Expected:${C_RESET} ${repo}--${expected_slug}"
      fi
      print -r -- ""
    fi
  }

  local wt_path="" branch="" head="" idx=0 line=""
  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ -n "$wt_path" ]]; then
        idx=$((idx + 1))
        display_worktree "$idx" "$wt_path" "$branch" "$head"
      fi
      wt_path=""; branch=""; head=""
      continue
    fi

    [[ "$line" == worktree\ * ]] && wt_path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
    [[ "$line" == HEAD\ * ]] && head="${line#HEAD }"
  done <<< "$out"

  # Handle last entry (no trailing blank line)
  if [[ -n "$wt_path" ]]; then
    idx=$((idx + 1))
    display_worktree "$idx" "$wt_path" "$branch" "$head"
  fi

  if [[ "$JSON_OUTPUT" == true ]]; then
    format_json "[${(j:, :)json_items}]"
  fi
}

cmd_status() {
  local repo="${1:-}"
  local stale_threshold=50
  local inactive_days=30

  [[ -n "$repo" ]] || die "Usage: wt status <repo>"

  validate_name "$repo" "repository"

  local git_dir
  git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  local out
  out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  # JSON output mode
  local json_items=()

  if [[ "$JSON_OUTPUT" != true ]]; then
    print -r -- ""
    print -r -- "${C_BOLD}Worktree Status: ${C_CYAN}$repo${C_RESET}"
    print -r -- ""
    printf "  ${C_DIM}%-28s %-10s %-14s %-6s %-7s %-10s${C_RESET}\n" "BRANCH" "STATE" "SYNC" "AGE" "MERGED" "SHA"
    print -r -- "  ${C_DIM}$(printf '%.0sâ”€' {1..83})${C_RESET}"
  fi

  local wt_path="" branch="" head="" line=""
  local sha st state_icon state_color changes counts ahead behind
  local age age_days merged_icon sync_display is_stale is_inactive
  local mismatches=()

  # Helper to display a worktree row
  display_status_row() {
    local p="$1" b="$2"

    sha="$(git -C "$p" rev-parse --short HEAD 2>/dev/null)" || sha="?"
    st="$(git -C "$p" status --porcelain 2>/dev/null)" || st=""
    state_icon="â—"
    state_color="$C_GREEN"
    is_stale=false
    is_inactive=false

    if [[ -n "$st" ]]; then
      changes="$(print -r -- "$st" | wc -l | tr -d ' ')"
      state_icon="â— $changes"
      state_color="$C_YELLOW"
    fi

    # Check for mismatch
    local match_result="$(check_branch_directory_match "$p" "$b" "$repo")"
    if [[ "$match_result" == mismatch\|* ]]; then
      local expected_slug="${match_result#mismatch|}"
      mismatches+=("${p:t}|$b|$expected_slug")
    fi

    # Get sync status
    counts="$(get_ahead_behind "$p" "$DEFAULT_BASE")"
    ahead="${counts%% *}"
    behind="${counts##* }"

    # Check if stale (>50 commits behind)
    if (( behind > stale_threshold )); then
      is_stale=true
      sync_display="${C_RED}â†‘$ahead â†“$behind${C_RESET}"
    else
      sync_display="â†‘$ahead â†“$behind"
    fi

    # Get age
    age="$(get_last_commit_age "$p")"
    age_days="$(get_commit_age_days "$p")"
    if (( age_days > inactive_days )); then
      is_inactive=true
    fi

    # Check if merged
    if is_branch_merged "$p" "$DEFAULT_BASE"; then
      merged_icon="${C_DIM}âœ“${C_RESET}"
    else
      merged_icon="${C_DIM}-${C_RESET}"
    fi

    # Apply row colouring for stale/inactive
    local branch_display="${b:0:26}"
    local age_display="$age"
    if [[ "$is_stale" == true ]]; then
      branch_display="${C_RED}${b:0:26}${C_RESET}"
      state_color="$C_RED"
    elif [[ "$is_inactive" == true ]]; then
      age_display="${C_YELLOW}$age${C_RESET}"
    fi

    if [[ "$JSON_OUTPUT" == true ]]; then
      local dirty=false
      [[ -n "$st" ]] && dirty=true
      local merged=false
      is_branch_merged "$p" "$DEFAULT_BASE" && merged=true
      json_items+=("{\"branch\": \"$(json_escape "$b")\", \"path\": \"$(json_escape "$p")\", \"sha\": \"$(json_escape "$sha")\", \"dirty\": $dirty, \"changes\": ${changes:-0}, \"ahead\": $ahead, \"behind\": $behind, \"stale\": $is_stale, \"age\": \"$age\", \"age_days\": $age_days, \"merged\": $merged}")
    else
      printf "  %-28s ${state_color}%-10s${C_RESET} %-14s %-6s %-7s ${C_DIM}%-10s${C_RESET}\n" \
        "$branch_display" "$state_icon" "$sync_display" "$age_display" "$merged_icon" "$sha"
    fi
  }

  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      # Skip bare repo entry (no branch) and process worktrees
      if [[ -n "$wt_path" && -n "$branch" && "$wt_path" != "$git_dir" ]]; then
        display_status_row "$wt_path" "$branch"
      fi
      wt_path=""
      branch=""
      head=""
      continue
    fi

    [[ "$line" == worktree\ * ]] && wt_path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
    [[ "$line" == HEAD\ * ]] && head="${line#HEAD }"
  done <<< "$out"

  # Handle last entry
  if [[ -n "$wt_path" && -n "$branch" && "$wt_path" != "$git_dir" ]]; then
    display_status_row "$wt_path" "$branch"
  fi

  # JSON output
  if [[ "$JSON_OUTPUT" == true ]]; then
    format_json "[${(j:, :)json_items}]"
    return 0
  fi

  # Show mismatch warnings
  if (( ${#mismatches[@]} > 0 )); then
    print -r -- ""
    print -r -- "${C_RED}${C_BOLD}Branch/Directory Mismatches Detected:${C_RESET}"
    for m in "${mismatches[@]}"; do
      local dir="${m%%|*}"
      local rest="${m#*|}"
      local actual_branch="${rest%%|*}"
      local expected_slug="${rest#*|}"
      print -r -- "  ${C_YELLOW}$dir${C_RESET}"
      print -r -- "    ${C_DIM}Current branch:${C_RESET}  ${C_MAGENTA}$actual_branch${C_RESET}"
      print -r -- "    ${C_DIM}Expected dir:${C_RESET}    ${repo}--${expected_slug}"
      print -r -- "    ${C_DIM}Fix:${C_RESET} Checkout correct branch or recreate worktree"
    done
  fi

  print -r -- ""
}

cmd_repos() {
  local repos; repos="$(list_repos)"

  if [[ -z "$repos" ]]; then
    dim "No repositories found in $HERD_ROOT"
    return 0
  fi

  if [[ "$JSON_OUTPUT" == true ]]; then
    local json_items=()
    while IFS= read -r repo; do
      local git_dir; git_dir="$(git_dir_for "$repo")"
      local wt_count; wt_count="$(git --git-dir="$git_dir" worktree list 2>/dev/null | wc -l | tr -d ' ')"
      wt_count=$((wt_count - 1))  # Subtract bare repo entry
      json_items+=("{\"name\": \"$(json_escape "$repo")\", \"worktrees\": $wt_count}")
    done <<< "$repos"
    format_json "[${(j:, :)json_items}]"
  else
    print -r -- ""
    print -r -- "${C_BOLD}Repositories in ${C_CYAN}$HERD_ROOT${C_RESET}"
    print -r -- ""
    while IFS= read -r repo; do
      local git_dir; git_dir="$(git_dir_for "$repo")"
      local wt_count; wt_count="$(git --git-dir="$git_dir" worktree list 2>/dev/null | wc -l | tr -d ' ')"
      wt_count=$((wt_count - 1))  # Subtract bare repo entry
      print -r -- "  ${C_GREEN}$repo${C_RESET} ${C_DIM}($wt_count worktrees)${C_RESET}"
    done <<< "$repos"
    print -r -- ""
  fi
}

cmd_report() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt report <repo> [--output <file>]"
  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  local output_file=""
  if [[ "${2:-}" == "--output" && -n "${3:-}" ]]; then
    output_file="$3"
  fi

  # Generate markdown report
  local report=""
  report+="# Worktree Report: $repo\n\n"
  report+="Generated: $(date '+%Y-%m-%d %H:%M:%S')\n\n"

  # Get worktree list
  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  report+="## Summary\n\n"

  local total=0 clean=0 dirty=0
  local wt_path="" branch="" head=""

  # First pass - count stats
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == worktree\ * ]]; then
      wt_path="${line#worktree }"
    elif [[ "$line" == "branch refs/heads/"* ]]; then
      branch="${line#branch refs/heads/}"
    elif [[ "$line" == HEAD\ * ]]; then
      head="${line#HEAD }"
    elif [[ -z "$line" && -n "$wt_path" ]]; then
      [[ "$wt_path" == *.git ]] && { wt_path=""; branch=""; head=""; continue; }
      total=$((total + 1))
      local status; status="$(git -C "$wt_path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
      if (( status > 0 )); then
        dirty=$((dirty + 1))
      else
        clean=$((clean + 1))
      fi
      wt_path=""; branch=""; head=""
    fi
  done <<< "$out"

  report+="| Metric | Count |\n"
  report+="|--------|-------|\n"
  report+="| Total worktrees | $total |\n"
  report+="| Clean | $clean |\n"
  report+="| With changes | $dirty |\n\n"

  report+="## Worktrees\n\n"
  report+="| Branch | Status | Ahead | Behind | Last Commit |\n"
  report+="|--------|--------|-------|--------|-------------|\n"

  # Second pass - generate table
  wt_path=""; branch=""; head=""
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == worktree\ * ]]; then
      wt_path="${line#worktree }"
    elif [[ "$line" == "branch refs/heads/"* ]]; then
      branch="${line#branch refs/heads/}"
    elif [[ "$line" == HEAD\ * ]]; then
      head="${line#HEAD }"
    elif [[ -z "$line" && -n "$wt_path" ]]; then
      [[ "$wt_path" == *.git ]] && { wt_path=""; branch=""; head=""; continue; }

      local status_count; status_count="$(git -C "$wt_path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
      local status_icon="clean"
      (( status_count > 0 )) && status_icon="$status_count changes"

      local ahead=0 behind=0
      local upstream; upstream="$(git -C "$wt_path" rev-parse --abbrev-ref '@{upstream}' 2>/dev/null)" || upstream=""
      if [[ -n "$upstream" ]]; then
        ahead="$(git -C "$wt_path" rev-list --count '@{upstream}'..HEAD 2>/dev/null)" || ahead=0
        behind="$(git -C "$wt_path" rev-list --count HEAD..'@{upstream}' 2>/dev/null)" || behind=0
      fi

      local last_commit; last_commit="$(git -C "$wt_path" log -1 --format='%s' 2>/dev/null | cut -c1-40)" || last_commit=""
      [[ ${#last_commit} -ge 40 ]] && last_commit="${last_commit}..."

      report+="| \`$branch\` | $status_icon | $ahead | $behind | $last_commit |\n"

      wt_path=""; branch=""; head=""
    fi
  done <<< "$out"

  report+="\n## Hooks Available\n\n"
  if [[ -d "$WT_HOOKS_DIR" ]]; then
    for hook_type in pre-add post-add pre-rm post-rm post-pull post-sync; do
      if [[ -x "$WT_HOOKS_DIR/$hook_type" ]] || [[ -d "$WT_HOOKS_DIR/${hook_type}.d" ]]; then
        report+="- \`$hook_type\` (enabled)\n"
      else
        report+="- \`$hook_type\` (not configured)\n"
      fi
    done
  else
    report+="No hooks directory found at \`$WT_HOOKS_DIR\`\n"
  fi

  # Output report
  if [[ -n "$output_file" ]]; then
    print -r -- "$report" > "$output_file"
    ok "Report saved to: $output_file"
  else
    print -r -- "$report"
  fi
}

# Calculate health score for a worktree (A-F grade)
# Returns: grade|score|details
calculate_health_score() {
  local wt_path="$1"
  local score=100
  local issues=()

  # Check commits behind (max -30 points)
  local counts; counts="$(get_ahead_behind "$wt_path" "$DEFAULT_BASE")"
  local behind="${counts##* }"
  if (( behind > 50 )); then
    score=$((score - 30))
    issues+=("behind:$behind")
  elif (( behind > 20 )); then
    score=$((score - 20))
    issues+=("behind:$behind")
  elif (( behind > 5 )); then
    score=$((score - 10))
    issues+=("behind:$behind")
  fi

  # Check uncommitted changes (max -20 points)
  local st; st="$(git -C "$wt_path" status --porcelain 2>/dev/null)"
  if [[ -n "$st" ]]; then
    local changes; changes="$(print -r -- "$st" | wc -l | tr -d ' ')"
    if (( changes > 20 )); then
      score=$((score - 20))
      issues+=("changes:$changes")
    elif (( changes > 5 )); then
      score=$((score - 10))
      issues+=("changes:$changes")
    else
      score=$((score - 5))
      issues+=("changes:$changes")
    fi
  fi

  # Check days since last commit (max -25 points)
  local age_days; age_days="$(get_commit_age_days "$wt_path")"
  if (( age_days > 60 )); then
    score=$((score - 25))
    issues+=("age:${age_days}d")
  elif (( age_days > 30 )); then
    score=$((score - 15))
    issues+=("age:${age_days}d")
  elif (( age_days > 14 )); then
    score=$((score - 5))
    issues+=("age:${age_days}d")
  fi

  # Check merge status (max -10 points)
  if ! is_branch_merged "$wt_path" "$DEFAULT_BASE"; then
    score=$((score - 10))
    issues+=("unmerged")
  fi

  # Check untracked files (max -5 points)
  local untracked=0
  if [[ -n "$st" ]]; then
    untracked="$(print -r -- "$st" | grep -c '^??' 2>/dev/null)" || untracked=0
  fi
  if (( untracked > 10 )); then
    score=$((score - 5))
    issues+=("untracked:$untracked")
  fi

  # Ensure score is between 0-100
  (( score < 0 )) && score=0
  (( score > 100 )) && score=100

  # Calculate grade
  local grade
  if (( score >= 90 )); then
    grade="A"
  elif (( score >= 80 )); then
    grade="B"
  elif (( score >= 70 )); then
    grade="C"
  elif (( score >= 60 )); then
    grade="D"
  else
    grade="F"
  fi

  print -r -- "$grade|$score|${(j:,:)issues}"
}

# Format health grade with colour
format_grade() {
  local grade="$1"
  case "$grade" in
    A) print -r -- "${C_GREEN}$grade${C_RESET}" ;;
    B) print -r -- "${C_GREEN}$grade${C_RESET}" ;;
    C) print -r -- "${C_YELLOW}$grade${C_RESET}" ;;
    D) print -r -- "${C_YELLOW}$grade${C_RESET}" ;;
    F) print -r -- "${C_RED}$grade${C_RESET}" ;;
    *) print -r -- "$grade" ;;
  esac
}

cmd_health() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt health <repo>"
  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  print -r -- ""
  print -r -- "${C_BOLD}Health Check: ${C_CYAN}$repo${C_RESET}"
  print -r -- ""

  # Show health scores for all worktrees
  print -r -- "${C_BOLD}Worktree Health Scores${C_RESET}"
  print -r -- ""
  printf "  ${C_DIM}%-5s %-30s %-6s %s${C_RESET}\n" "GRADE" "BRANCH" "SCORE" "ISSUES"
  print -r -- "  ${C_DIM}$(printf '%.0sâ”€' {1..70})${C_RESET}"

  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || out=""
  local wt_path="" branch=""
  local total_score=0 wt_count=0

  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      wt_path="${line#worktree }"
    elif [[ "$line" == branch\ refs/heads/* ]]; then
      branch="${line#branch refs/heads/}"
    elif [[ -z "$line" && -n "$wt_path" && "$wt_path" != *.git && -n "$branch" ]]; then
      if [[ -d "$wt_path" ]]; then
        local result; result="$(calculate_health_score "$wt_path")"
        local grade="${result%%|*}"
        local rest="${result#*|}"
        local score="${rest%%|*}"
        local issues="${rest#*|}"

        total_score=$((total_score + score))
        wt_count=$((wt_count + 1))

        local grade_colored; grade_colored="$(format_grade "$grade")"
        local branch_display="${branch:0:28}"
        local issues_display="${issues//,/ }"

        printf "  %-5s %-30s %-6s ${C_DIM}%s${C_RESET}\n" \
          "$grade_colored" "$branch_display" "$score" "$issues_display"
      fi
      wt_path=""
      branch=""
    fi
  done <<< "$out"

  if (( wt_count > 0 )); then
    local avg_score=$((total_score / wt_count))
    local avg_grade
    if (( avg_score >= 90 )); then avg_grade="A"
    elif (( avg_score >= 80 )); then avg_grade="B"
    elif (( avg_score >= 70 )); then avg_grade="C"
    elif (( avg_score >= 60 )); then avg_grade="D"
    else avg_grade="F"
    fi

    print -r -- ""
    print -r -- "  ${C_BOLD}Average:${C_RESET} $(format_grade "$avg_grade") (${avg_score}/100)"
  fi
  print -r -- ""

  local issues=0 warnings=0

  # Check for stale worktrees
  print -r -- "${C_BOLD}Stale Worktrees${C_RESET}"
  local stale; stale="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null | grep -A1 '^worktree ' | grep -v '^worktree ' | grep -v '^--$' | while read -r path; do
    [[ -n "$wt_path" && ! -d "$wt_path" ]] && echo "$wt_path"
  done)"
  if [[ -n "$stale" ]]; then
    warn "Found stale worktree references:"
    print -r -- "$stale" | while read -r path; do
      print -r -- "  ${C_RED}x${C_RESET} $wt_path"
    done
    issues=$((issues + 1))
    dim "  Fix: wt prune $repo"
  else
    ok "No stale worktrees"
  fi
  print -r -- ""

  # Check for orphaned databases
  print -r -- "${C_BOLD}Database Health${C_RESET}"
  if command -v mysql >/dev/null 2>&1; then
    local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER" -N -B)
    [[ -n "$DB_PASSWORD" ]] && mysql_cmd+=(-p"$DB_PASSWORD")

    local dbs; dbs="$("${mysql_cmd[@]}" -e "SHOW DATABASES LIKE '${repo}__%'" 2>/dev/null)" || dbs=""

    if [[ -n "$dbs" ]]; then
      local orphaned=0
      while read -r db; do
        local found=false
        local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || out=""
        while IFS= read -r line; do
          if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            local wt_db; wt_db="$(db_name_for "$repo" "${wt_path##*--}")"
            [[ "$wt_db" == "$db" ]] && found=true && break
          fi
        done <<< "$out"

        if [[ "$found" == false ]]; then
          [[ $orphaned -eq 0 ]] && warn "Potentially orphaned databases:"
          print -r -- "  ${C_YELLOW}?${C_RESET} $db"
          orphaned=$((orphaned + 1))
        fi
      done <<< "$dbs"

      if [[ $orphaned -eq 0 ]]; then
        ok "No orphaned databases found"
      else
        warnings=$((warnings + orphaned))
        dim "  Verify and drop if not needed: mysql -e 'DROP DATABASE <name>'"
      fi
    else
      dim "  No databases found matching pattern ${repo}__*"
    fi
  else
    dim "  MySQL not available - skipping database checks"
  fi
  print -r -- ""

  # Check for missing .env files
  print -r -- "${C_BOLD}Environment Files${C_RESET}"
  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || out=""
  local missing_env=0
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      local wt_path="${line#worktree }"
      [[ "$wt_path" == *.git ]] && continue
      if [[ -f "$wt_path/.env.example" && ! -f "$wt_path/.env" ]]; then
        [[ $missing_env -eq 0 ]] && warn "Worktrees missing .env file:"
        print -r -- "  ${C_YELLOW}!${C_RESET} ${path##*/}"
        missing_env=$((missing_env + 1))
      fi
    fi
  done <<< "$out"
  if [[ $missing_env -eq 0 ]]; then
    ok "All worktrees have .env files"
  else
    warnings=$((warnings + missing_env))
    dim "  Fix: cd <worktree> && cp .env.example .env"
  fi
  print -r -- ""

  # Check for branch/directory mismatches
  print -r -- "${C_BOLD}Branch Consistency${C_RESET}"
  local mismatches=0
  check_worktree_mismatches "$git_dir"
  mismatches=$?
  if [[ $mismatches -eq 0 ]]; then
    ok "All worktrees match their expected branches"
  else
    issues=$((issues + mismatches))
  fi
  print -r -- ""

  # Summary
  print -r -- "${C_BOLD}Summary${C_RESET}"
  if [[ $issues -eq 0 && $warnings -eq 0 ]]; then
    ok "No issues found - repository is healthy!"
  else
    [[ $issues -gt 0 ]] && warn "$issues issue(s) need attention"
    [[ $warnings -gt 0 ]] && dim "  $warnings warning(s) to review"
  fi
  print -r -- ""
}

# Dashboard - Overview of all repositories and worktrees
cmd_dashboard() {
  print -r -- ""
  print -r -- "${C_BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C_RESET}"
  print -r -- "${C_BOLD}â•‘                    wt Dashboard                                    â•‘${C_RESET}"
  print -r -- "${C_BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C_RESET}"
  print -r -- ""

  local total_repos=0
  local total_worktrees=0
  local total_dirty=0
  local total_stale=0

  # Declare loop-scoped variables BEFORE the loop to avoid zsh local re-declaration bug
  local repo_name out wt_path branch line
  local repo_wt_count repo_dirty repo_stale repo_grade_sum
  local result grade rest score st age_days
  local avg_grade avg_score grade_colored
  local wt wt_branch wt_rest wt_grade wt_score wt_grade_colored
  local status_parts shown

  # Collect data for all repos
  for git_dir in "$HERD_ROOT"/*.git(N); do
    [[ -d "$git_dir" ]] || continue
    repo_name="${${git_dir:t}%.git}"
    total_repos=$((total_repos + 1))

    out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || continue
    wt_path=""
    branch=""
    repo_wt_count=0
    repo_dirty=0
    repo_stale=0
    repo_grade_sum=0

    # Collect worktree info for this repo
    local wt_info=()

    while IFS= read -r line; do
      if [[ "$line" == worktree\ * ]]; then
        wt_path="${line#worktree }"
      elif [[ "$line" == branch\ refs/heads/* ]]; then
        branch="${line#branch refs/heads/}"
      elif [[ -z "$line" && -n "$wt_path" && "$wt_path" != *.git && -n "$branch" && -d "$wt_path" ]]; then
        # Process this worktree entry
        repo_wt_count=$((repo_wt_count + 1))
        total_worktrees=$((total_worktrees + 1))

        # Get health score
        result="$(calculate_health_score "$wt_path")"
        grade="${result%%|*}"
        rest="${result#*|}"
        score="${rest%%|*}"
        repo_grade_sum=$((repo_grade_sum + score))

        # Check dirty
        st="$(git -C "$wt_path" status --porcelain 2>/dev/null)" || st=""
        if [[ -n "$st" ]]; then
          repo_dirty=$((repo_dirty + 1))
          total_dirty=$((total_dirty + 1))
        fi

        # Check stale
        age_days="$(get_commit_age_days "$wt_path")"
        if (( age_days > 30 )); then
          repo_stale=$((repo_stale + 1))
          total_stale=$((total_stale + 1))
        fi

        wt_info+=("$branch|$grade|$score")
        wt_path=""
        branch=""
      fi
    done <<< "$out"
    # Handle last entry (no trailing newline in porcelain output)
    if [[ -n "$wt_path" && "$wt_path" != *.git && -n "$branch" && -d "$wt_path" ]]; then
      repo_wt_count=$((repo_wt_count + 1))
      total_worktrees=$((total_worktrees + 1))
      result="$(calculate_health_score "$wt_path")"
      grade="${result%%|*}"
      rest="${result#*|}"
      score="${rest%%|*}"
      repo_grade_sum=$((repo_grade_sum + score))
      st="$(git -C "$wt_path" status --porcelain 2>/dev/null)" || st=""
      [[ -n "$st" ]] && { repo_dirty=$((repo_dirty + 1)); total_dirty=$((total_dirty + 1)); }
      age_days="$(get_commit_age_days "$wt_path")"
      (( age_days > 30 )) && { repo_stale=$((repo_stale + 1)); total_stale=$((total_stale + 1)); }
      wt_info+=("$branch|$grade|$score")
    fi

    # Calculate average grade for repo
    avg_grade="?"
    if (( repo_wt_count > 0 )); then
      avg_score=$((repo_grade_sum / repo_wt_count))
      if (( avg_score >= 90 )); then avg_grade="A"
      elif (( avg_score >= 80 )); then avg_grade="B"
      elif (( avg_score >= 70 )); then avg_grade="C"
      elif (( avg_score >= 60 )); then avg_grade="D"
      else avg_grade="F"
      fi
    fi

    # Print repo summary
    grade_colored="$(format_grade "$avg_grade")"
    print -r -- "${C_BOLD}${C_CYAN}$repo_name${C_RESET} ${C_DIM}($repo_wt_count worktrees)${C_RESET} $grade_colored"

    # Show status indicators
    status_parts=()
    if (( repo_dirty > 0 )); then
      status_parts+=("${C_YELLOW}$repo_dirty dirty${C_RESET}")
    fi
    if (( repo_stale > 0 )); then
      status_parts+=("${C_RED}$repo_stale stale${C_RESET}")
    fi
    if (( ${#status_parts[@]} > 0 )); then
      print -r -- "  ${(j: | :)status_parts}"
    fi

    # Show worktrees (limit to 5)
    shown=0
    for wt in "${wt_info[@]}"; do
      (( shown >= 5 )) && break
      wt_branch="${wt%%|*}"
      wt_rest="${wt#*|}"
      wt_grade="${wt_rest%%|*}"
      wt_score="${wt_rest#*|}"
      wt_grade_colored="$(format_grade "$wt_grade")"
      print -r -- "  ${C_DIM}â”œâ”€${C_RESET} ${C_MAGENTA}${wt_branch:0:35}${C_RESET} $wt_grade_colored"
      shown=$((shown + 1))
    done

    if (( ${#wt_info[@]} > 5 )); then
      print -r -- "  ${C_DIM}â””â”€ ... and $((${#wt_info[@]} - 5)) more${C_RESET}"
    elif (( ${#wt_info[@]} > 0 )); then
      # Change last â”œâ”€ to â””â”€ for visual consistency
      :
    fi
    print -r -- ""
  done

  # Print summary
  print -r -- "${C_DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${C_RESET}"
  print -r -- ""
  print -r -- "${C_BOLD}Summary${C_RESET}"
  print -r -- "  Repositories:  ${C_GREEN}$total_repos${C_RESET}"
  print -r -- "  Worktrees:     ${C_GREEN}$total_worktrees${C_RESET}"
  if (( total_dirty > 0 )); then
    print -r -- "  With changes:  ${C_YELLOW}$total_dirty${C_RESET}"
  fi
  if (( total_stale > 0 )); then
    print -r -- "  Stale (>30d):  ${C_RED}$total_stale${C_RESET}"
  fi
  print -r -- ""

  dim "Commands: wt status <repo> | wt health <repo> | wt recent"
  print -r -- ""
}

# utility.sh - Utility and maintenance commands

cmd_templates() {
  local template_name="${1:-}"

  if [[ -z "$template_name" ]]; then
    # List all templates
    print -r -- ""
    print -r -- "${C_BOLD}Available Templates${C_RESET}"
    print -r -- ""
    list_templates
    print -r -- ""
    print -r -- "${C_DIM}Usage: wt templates <name>  - Show template details${C_RESET}"
    print -r -- "${C_DIM}       wt add <repo> <branch> --template=<name>${C_RESET}"
    print -r -- ""
    return 0
  fi

  # Validate template name first (security: prevent path traversal)
  validate_template_name "$template_name"

  # Show specific template details
  local template_file="$WT_TEMPLATES_DIR/${template_name}.conf"

  if [[ ! -f "$template_file" ]]; then
    die "Template not found: $template_name
       Expected: $template_file"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Template: ${C_CYAN}$template_name${C_RESET}"
  print -r -- ""

  # Extract description
  local desc; desc="$(extract_template_desc "$template_file")"
  if [[ -n "$desc" ]]; then
    print -r -- "${C_DIM}Description:${C_RESET} $desc"
    print -r -- ""
  fi

  print -r -- "${C_DIM}File:${C_RESET} $template_file"
  print -r -- ""
  print -r -- "${C_BOLD}Settings:${C_RESET}"

  # Show all WT_SKIP_* settings
  while IFS='=' read -r key value || [[ -n "$key" ]]; do
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"

    case "$key" in
      WT_SKIP_*)
        value="${value#\"}"
        value="${value%\"}"
        value="${value%%#*}"
        value="${value%"${value##*[![:space:]]}"}"
        if [[ "$value" == "true" ]]; then
          print -r -- "  ${C_YELLOW}$key${C_RESET} = ${C_RED}true${C_RESET} (skipped)"
        else
          print -r -- "  ${C_GREEN}$key${C_RESET} = ${C_GREEN}false${C_RESET} (enabled)"
        fi
        ;;
    esac
  done < "$template_file"

  print -r -- ""
  print -r -- "${C_DIM}Usage: wt add <repo> <branch> --template=$template_name${C_RESET}"
  print -r -- ""
}

cmd_doctor() {
  print -r -- ""
  print -r -- "${C_BOLD}wt doctor${C_RESET}"
  print -r -- ""

  local issues=0

  # Check HERD_ROOT
  print -r -- "${C_BOLD}Configuration${C_RESET}"
  if [[ -d "$HERD_ROOT" ]]; then
    ok "HERD_ROOT: $HERD_ROOT"
  else
    warn "HERD_ROOT does not exist: $HERD_ROOT"
    issues=$((issues + 1))
  fi

  if [[ -d "$DB_BACKUP_DIR" ]]; then
    ok "DB_BACKUP_DIR: $DB_BACKUP_DIR"
  else
    dim "  DB_BACKUP_DIR does not exist (will be created on first backup): $DB_BACKUP_DIR"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Required Tools${C_RESET}"

  # Check git
  if command -v git >/dev/null 2>&1; then
    local git_version; git_version="$(git --version 2>/dev/null | head -1)"
    ok "git: $git_version"
  else
    warn "git: not found"
    issues=$((issues + 1))
  fi

  # Check composer
  if command -v composer >/dev/null 2>&1; then
    local composer_version; composer_version="$(composer --version 2>/dev/null | head -1)"
    ok "composer: $composer_version"
  else
    warn "composer: not found"
    issues=$((issues + 1))
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Optional Tools${C_RESET}"

  # Check mysql
  if command -v mysql >/dev/null 2>&1; then
    local mysql_version; mysql_version="$(mysql --version 2>/dev/null | head -1)"
    ok "mysql: $mysql_version"

    # Test connection
    local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
    if [[ -n "$DB_PASSWORD" ]]; then
      mysql_cmd+=(-p"$DB_PASSWORD")
    fi
    if "${mysql_cmd[@]}" -e "SELECT 1" >/dev/null 2>&1; then
      ok "  MySQL connection: OK"
    else
      warn "  MySQL connection: FAILED (check DB_HOST, DB_USER, DB_PASSWORD)"
    fi
  else
    dim "  mysql: not found (database features disabled)"
  fi

  # Check herd
  if command -v herd >/dev/null 2>&1; then
    ok "herd: installed"
  else
    dim "  herd: not found (site securing disabled)"
  fi

  # Check fzf
  if command -v fzf >/dev/null 2>&1; then
    ok "fzf: installed"
  else
    dim "  fzf: not found (interactive selection disabled)"
  fi

  # Check editor
  if command -v "$DEFAULT_EDITOR" >/dev/null 2>&1; then
    ok "editor: $DEFAULT_EDITOR"
  else
    dim "  editor: $DEFAULT_EDITOR not found"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Config Files${C_RESET}"

  local config_file="${WT_CONFIG:-$HOME/.wtrc}"
  if [[ -f "$config_file" ]]; then
    ok "User config: $config_file"
  else
    dim "  User config: $config_file (not found)"
  fi

  if [[ -f "$HERD_ROOT/.wtconfig" ]]; then
    ok "Project config: $HERD_ROOT/.wtconfig"
  else
    dim "  Project config: $HERD_ROOT/.wtconfig (not found)"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Hooks${C_RESET}"

  if [[ -d "$WT_HOOKS_DIR" ]]; then
    ok "Hooks directory: $WT_HOOKS_DIR"

    # Check for post-add hook
    if [[ -x "$WT_HOOKS_DIR/post-add" ]]; then
      ok "  post-add: enabled"
    elif [[ -f "$WT_HOOKS_DIR/post-add" ]]; then
      warn "  post-add: exists but not executable"
    else
      dim "  post-add: not configured"
    fi

    # Check for post-add.d directory
    if [[ -d "$WT_HOOKS_DIR/post-add.d" ]]; then
      local hook_count; hook_count="$(ls -1 "$WT_HOOKS_DIR/post-add.d" 2>/dev/null | wc -l | tr -d ' ')" || hook_count=0
      if (( hook_count > 0 )); then
        ok "  post-add.d/: $hook_count script(s)"
      fi
    fi

    # Check for post-rm hook
    if [[ -x "$WT_HOOKS_DIR/post-rm" ]]; then
      ok "  post-rm: enabled"
    elif [[ -f "$WT_HOOKS_DIR/post-rm" ]]; then
      warn "  post-rm: exists but not executable"
    else
      dim "  post-rm: not configured"
    fi

    # Check for post-rm.d directory
    if [[ -d "$WT_HOOKS_DIR/post-rm.d" ]]; then
      local hook_count; hook_count="$(ls -1 "$WT_HOOKS_DIR/post-rm.d" 2>/dev/null | wc -l | tr -d ' ')" || hook_count=0
      if (( hook_count > 0 )); then
        ok "  post-rm.d/: $hook_count script(s)"
      fi
    fi
  else
    dim "  Hooks directory: $WT_HOOKS_DIR (not found)"
    dim "  Create hooks with: mkdir -p $WT_HOOKS_DIR"
  fi

  print -r -- ""
  if (( issues > 0 )); then
    warn "$issues issue(s) found"
  else
    ok "All checks passed!"
  fi
  print -r -- ""
}

cmd_cleanup_herd() {
  print -r -- ""
  print -r -- "${C_BOLD}Cleaning orphaned Herd configs${C_RESET}"
  print -r -- ""

  if ! command -v herd >/dev/null 2>&1; then
    die "Herd is not installed"
  fi

  local nginx_dir="$HERD_CONFIG/valet/Nginx"
  local cert_dir="$HERD_CONFIG/valet/Certificates"
  local orphaned=()
  local cleaned=0

  if [[ ! -d "$nginx_dir" ]]; then
    warn "Nginx config directory not found: $nginx_dir"
    return 1
  fi

  info "Scanning for orphaned configs..."

  # Find all nginx configs that look like worktree sites (contain --)
  for config in "$nginx_dir"/*--*.test(N); do
    [[ -f "$config" ]] || continue
    local site_name="${config:t}"  # e.g., scooda--feature-xyz.test
    local folder_name="${site_name%.test}"  # e.g., scooda--feature-xyz
    local wt_path="$HERD_ROOT/$folder_name"

    # Check if the worktree directory exists
    if [[ ! -d "$wt_path" ]]; then
      orphaned+=("$site_name")
    fi
  done

  if (( ${#orphaned[@]} == 0 )); then
    ok "No orphaned configs found"
    print -r -- ""
    return 0
  fi

  print -r -- ""
  warn "Found ${C_BOLD}${#orphaned[@]}${C_RESET}${C_YELLOW} orphaned config(s):${C_RESET}"
  for site in "${orphaned[@]}"; do
    print -r -- "  ${C_DIM}â€¢${C_RESET} $site"
  done
  print -r -- ""

  if [[ "$FORCE" == false ]]; then
    print -n "${C_YELLOW}Remove these orphaned configs? [y/N]${C_RESET} "
    local response
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || { dim "Aborted"; return 0; }
  fi

  print -r -- ""
  for site_name in "${orphaned[@]}"; do
    local folder_name="${site_name%.test}"
    info "Cleaning ${C_CYAN}$site_name${C_RESET}"

    # Remove nginx config
    local nginx_config="$nginx_dir/$site_name"
    if [[ -f "$nginx_config" ]]; then
      /bin/rm -f "$nginx_config" 2>/dev/null
    fi

    # Remove certificate files
    for ext in crt key csr conf; do
      local cert_file="$cert_dir/${site_name}.${ext}"
      if [[ -f "$cert_file" ]]; then
        /bin/rm -f "$cert_file" 2>/dev/null
      fi
    done

    cleaned=$((cleaned + 1))
  done

  # Restart nginx to apply changes
  info "Restarting Herd nginx..."
  herd restart >/dev/null 2>&1

  print -r -- ""
  ok "Cleaned ${C_BOLD}$cleaned${C_RESET} orphaned config(s)"
  print -r -- ""
}

cmd_unlock() {
  local repo="${1:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    dim "  Detected: $repo"
  fi

  if [[ -n "$repo" ]]; then
    # Unlock specific repo
    validate_name "$repo" "repository"
    local git_dir; git_dir="$(git_dir_for "$repo")"
    ensure_bare_repo "$git_dir"

    local worktrees_dir="$git_dir/worktrees"
    if [[ ! -d "$worktrees_dir" ]]; then
      dim "No worktrees directory found for $repo"
      return 0
    fi

    local count=0
    for lock_file in "$worktrees_dir"/*/index.lock(N); do
      if [[ -f "$lock_file" ]]; then
        local wt_name="${${lock_file:h}:t}"
        rm -f "$lock_file"
        ok "Removed lock: ${C_CYAN}$wt_name${C_RESET}"
        count=$((count + 1))
      fi
    done

    if (( count == 0 )); then
      ok "No stale lock files found for ${C_CYAN}$repo${C_RESET}"
    else
      ok "Removed ${C_BOLD}$count${C_RESET} lock file(s)"
    fi
  else
    # Unlock all repos
    info "Scanning all repositories..."
    local total=0

    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      local repo_name="${${git_dir:t}%.git}"
      local worktrees_dir="$git_dir/worktrees"

      [[ -d "$worktrees_dir" ]] || continue

      for lock_file in "$worktrees_dir"/*/index.lock(N); do
        if [[ -f "$lock_file" ]]; then
          local wt_name="${${lock_file:h}:t}"
          rm -f "$lock_file"
          ok "Removed lock: ${C_CYAN}$repo_name${C_RESET} / ${C_MAGENTA}$wt_name${C_RESET}"
          total=$((total + 1))
        fi
      done
    done

    if (( total == 0 )); then
      ok "No stale lock files found"
    else
      ok "Removed ${C_BOLD}$total${C_RESET} lock file(s)"
    fi
  fi
}

# New command: repair - Scan for and fix common issues
cmd_repair() {
  local repo="${1:-}"

  if [[ -z "$repo" ]]; then
    # Repair all repos
    info "Scanning all repositories for issues..."
    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      local repo_name="${${git_dir:t}%.git}"
      _repair_repo "$repo_name" "$git_dir"
    done
  else
    validate_name "$repo" "repository"
    local git_dir; git_dir="$(git_dir_for "$repo")"
    ensure_bare_repo "$git_dir"
    _repair_repo "$repo" "$git_dir"
  fi
}

_repair_repo() {
  local repo="$1"
  local git_dir="$2"

  print -r -- ""
  print -r -- "${C_BOLD}Repairing: ${C_CYAN}$repo${C_RESET}"
  print -r -- ""

  local fixed=0

  # 1. Prune orphaned worktrees
  info "Checking for orphaned worktrees..."
  local pruned; pruned="$(git --git-dir="$git_dir" worktree prune -v 2>&1)" || true
  if [[ -n "$pruned" && "$pruned" != *"Nothing to prune"* ]]; then
    print -r -- "$pruned" | while read -r line; do
      ok "  Pruned: $line"
    done
    fixed=$((fixed + 1))
  else
    dim "  No orphaned worktrees"
  fi

  # 2. Clean stale index locks
  info "Checking for stale index locks..."
  local locks_cleaned=0
  check_index_locks "$git_dir" "--auto-clean"
  locks_cleaned=$?
  if (( locks_cleaned > 0 )); then
    fixed=$((fixed + 1))
  else
    dim "  No stale locks"
  fi

  # 3. Check for missing .git files in worktrees
  info "Checking worktree integrity..."
  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  local wt_wt_path=""
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      wt_path="${line#worktree }"
    elif [[ -z "$line" && -n "$wt_path" && "$wt_path" != *.git ]]; then
      if [[ -d "$wt_path" && ! -f "$wt_path/.git" ]]; then
        warn "  Missing .git file: ${path##*/}"
        dim "    May need to recreate worktree"
      fi
      wt_path=""
    fi
  done <<< "$out"

  print -r -- ""
  if (( fixed > 0 )); then
    ok "Fixed $fixed issue(s) in $repo"
  else
    ok "No issues found in $repo"
  fi
}

# Parallel commands

cmd_build_all() {
  local repo="${1:-}"

  # Multi-repo mode
  if [[ "${ALL_REPOS:-false}" == true ]]; then
    info "Building all worktrees across all repositories..."
    print -r -- ""

    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      local repo_name="${${git_dir:t}%.git}"
      print -r -- "${C_BOLD}${C_CYAN}$repo_name${C_RESET}"
      _build_all_for_repo "$repo_name" "$git_dir"
      print -r -- ""
    done

    ok "Build complete across all repositories"
    notify "wt build-all" "Completed across all repos"
    return 0
  fi

  [[ -n "$repo" ]] || die "Usage: wt build-all <repo>
       Use --all-repos to build across all repositories."

  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  _build_all_for_repo "$repo" "$git_dir"
  notify "wt build-all" "Completed for $repo"
}

_build_all_for_repo() {
  local repo="$1"
  local git_dir="$2"

  # Collect worktrees
  local worktrees=()
  collect_worktrees "$git_dir" worktrees

  (( ${#worktrees[@]} > 0 )) || { dim "  No worktrees found."; return 0; }

  # Build operations list
  local operations=()
  for wt_entry in "${worktrees[@]}"; do
    local wt_path="${wt_entry%%|*}"
    local wt_branch="${wt_entry##*|}"
    if [[ -f "$wt_path/package.json" ]]; then
      operations+=("$wt_branch|cd '$wt_path' && npm run build")
    fi
  done

  if (( ${#operations[@]} > 0 )); then
    parallel_run report_results "${operations[@]}"
  else
    dim "  No worktrees with package.json"
  fi
}

cmd_exec_all() {
  local repo="${1:-}"

  # Multi-repo mode
  if [[ "${ALL_REPOS:-false}" == true ]]; then
    shift || true
    local cmd=("$@")
    (( ${#cmd[@]} > 0 )) || die "Usage: wt exec-all --all-repos <command...>"

    local cmd_str="${cmd[*]}"
    info "Executing '$cmd_str' across all repositories..."
    print -r -- ""

    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      local repo_name="${${git_dir:t}%.git}"
      print -r -- "${C_BOLD}${C_CYAN}$repo_name${C_RESET}"
      _exec_all_for_repo "$repo_name" "$git_dir" "$cmd_str"
      print -r -- ""
    done

    ok "Execution complete across all repositories"
    return 0
  fi

  shift || true
  local cmd=("$@")

  [[ -n "$repo" && ${#cmd[@]} -gt 0 ]] || die "Usage: wt exec-all <repo> <command...>
       Use --all-repos to execute across all repositories."

  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  _exec_all_for_repo "$repo" "$git_dir" "${cmd[*]}"
}

_exec_all_for_repo() {
  local repo="$1"
  local git_dir="$2"
  local cmd_str="$3"

  # Collect worktrees
  local worktrees=()
  collect_worktrees "$git_dir" worktrees

  (( ${#worktrees[@]} > 0 )) || { dim "  No worktrees found."; return 0; }

  # Build operations list
  local operations=()
  for wt_entry in "${worktrees[@]}"; do
    local wt_path="${wt_entry%%|*}"
    local wt_branch="${wt_entry##*|}"
    operations+=("$wt_branch|cd '$wt_path' && $cmd_str")
  done

  parallel_run report_results "${operations[@]}"
}

# ============================================================================
# New commands: upgrade, info, recent, clean, alias
# ============================================================================

cmd_upgrade() {
  print -r -- ""
  print -r -- "${C_BOLD}wt upgrade${C_RESET}"
  print -r -- ""

  # Find the wt script location
  local wt_path; wt_path="$(command -v wt 2>/dev/null)"
  if [[ -z "$wt_path" ]]; then
    die "Cannot find wt in PATH"
  fi

  # Resolve symlink to find repo
  local real_path; real_path="$(readlink "$wt_path" 2>/dev/null || echo "$wt_path")"
  local repo_dir="${real_path:h}"

  # Check if it's a git repo
  if [[ ! -d "$repo_dir/.git" && ! -f "$repo_dir/.git" ]]; then
    # Try parent directory
    repo_dir="${repo_dir:h}"
    if [[ ! -d "$repo_dir/.git" && ! -f "$repo_dir/.git" ]]; then
      die "wt is not installed from a git repository. Cannot upgrade."
    fi
  fi

  info "Repository: ${C_CYAN}$repo_dir${C_RESET}"

  # Check current version
  local current_version="$VERSION"
  info "Current version: ${C_YELLOW}v$current_version${C_RESET}"

  # Fetch latest
  info "Fetching updates..."
  if ! git -C "$repo_dir" fetch origin --quiet 2>/dev/null; then
    die "Failed to fetch updates. Check your network connection."
  fi

  # Check if we're behind
  local local_head; local_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null)"
  local remote_head; remote_head="$(git -C "$repo_dir" rev-parse origin/main 2>/dev/null || git -C "$repo_dir" rev-parse origin/master 2>/dev/null)"

  if [[ "$local_head" == "$remote_head" ]]; then
    ok "Already up to date!"
    print -r -- ""
    return 0
  fi

  # Show what's new
  local commits_behind; commits_behind="$(git -C "$repo_dir" rev-list --count HEAD..origin/main 2>/dev/null || git -C "$repo_dir" rev-list --count HEAD..origin/master 2>/dev/null || echo 0)"
  info "Updates available: ${C_GREEN}$commits_behind${C_RESET} new commit(s)"
  print -r -- ""

  # Show recent commits
  dim "Recent changes:"
  git -C "$repo_dir" log --oneline HEAD..origin/main 2>/dev/null | head -5 | while read -r line; do
    print -r -- "  ${C_DIM}â€¢${C_RESET} $line"
  done
  print -r -- ""

  # Confirm upgrade
  if [[ "$FORCE" != true ]]; then
    print -n "${C_YELLOW}Upgrade now? [y/N]${C_RESET} "
    local response
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || { dim "Aborted"; return 0; }
  fi

  # Pull updates
  info "Pulling updates..."
  if ! git -C "$repo_dir" pull --rebase origin main 2>/dev/null && ! git -C "$repo_dir" pull --rebase origin master 2>/dev/null; then
    die "Failed to pull updates. You may need to resolve conflicts manually."
  fi

  # Rebuild if build.sh exists
  if [[ -x "$repo_dir/build.sh" ]]; then
    info "Rebuilding..."
    if ! "$repo_dir/build.sh" >/dev/null 2>&1; then
      warn "Build failed. Try running ./build.sh manually."
    fi
  fi

  # Show new version
  local new_version
  if [[ -f "$repo_dir/lib/00-header.sh" ]]; then
    new_version="$(grep '^VERSION=' "$repo_dir/lib/00-header.sh" 2>/dev/null | cut -d'"' -f2)"
  elif [[ -f "$repo_dir/wt" ]]; then
    new_version="$(grep '^VERSION=' "$repo_dir/wt" 2>/dev/null | head -1 | cut -d'"' -f2)"
  fi
  new_version="${new_version:-unknown}"

  print -r -- ""
  ok "Upgraded: ${C_YELLOW}v$current_version${C_RESET} â†’ ${C_GREEN}v$new_version${C_RESET}"
  print -r -- ""

  # Verify
  dim "Verify with: wt --version"
  print -r -- ""
}

cmd_version_check() {
  print -r -- ""
  print -r -- "${C_BOLD}Checking for updates...${C_RESET}"
  print -r -- ""

  local current_version="$VERSION"
  info "Installed: ${C_YELLOW}v$current_version${C_RESET}"

  # Find repo directory
  local wt_path; wt_path="$(command -v wt 2>/dev/null)"
  local real_path; real_path="$(readlink "$wt_path" 2>/dev/null || echo "$wt_path")"
  local repo_dir="${real_path:h}"

  if [[ ! -d "$repo_dir/.git" && ! -f "$repo_dir/.git" ]]; then
    repo_dir="${repo_dir:h}"
  fi

  if [[ -d "$repo_dir/.git" || -f "$repo_dir/.git" ]]; then
    # Fetch and check
    git -C "$repo_dir" fetch origin --quiet 2>/dev/null || true

    local local_head; local_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null)"
    local remote_head; remote_head="$(git -C "$repo_dir" rev-parse origin/main 2>/dev/null || git -C "$repo_dir" rev-parse origin/master 2>/dev/null)"

    if [[ "$local_head" == "$remote_head" ]]; then
      ok "You're running the latest version!"
    else
      local commits_behind; commits_behind="$(git -C "$repo_dir" rev-list --count HEAD..origin/main 2>/dev/null || git -C "$repo_dir" rev-list --count HEAD..origin/master 2>/dev/null || echo "?")"
      warn "Update available: ${C_GREEN}$commits_behind${C_RESET} new commit(s)"
      dim "  Run: wt upgrade"
    fi
  else
    dim "Cannot check for updates (not installed from git)"
  fi

  print -r -- ""
}

cmd_info() {
  local repo="${1:-}"
  local branch="${2:-}"

  # Auto-detect from current directory
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  [[ -n "$repo" ]] || die "Usage: wt info <repo> [branch]"
  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  # If no branch specified, use fzf or error
  if [[ -z "$branch" ]]; then
    if command -v fzf >/dev/null 2>&1; then
      branch="$(select_worktree "$git_dir")" || return 1
    else
      die "Branch required. Usage: wt info <repo> <branch>"
    fi
  fi

  validate_name "$branch" "branch"

  local wt_path; wt_path="$(wt_path_for "$repo" "$branch")"

  if [[ ! -d "$wt_path" ]]; then
    die "Worktree not found: $wt_path"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Worktree Info: ${C_CYAN}$repo${C_RESET} / ${C_MAGENTA}$branch${C_RESET}"
  print -r -- ""

  # Basic info
  print -r -- "${C_BOLD}Location${C_RESET}"
  print -r -- "  Path:     ${C_CYAN}$wt_path${C_RESET}"
  local url; url="$(url_for "$repo" "$branch")"
  print -r -- "  URL:      ${C_BLUE}$url${C_RESET}"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  print -r -- "  Database: ${C_YELLOW}$db_name${C_RESET}"
  print -r -- ""

  # Git info
  print -r -- "${C_BOLD}Git${C_RESET}"
  local sha; sha="$(git -C "$wt_path" rev-parse HEAD 2>/dev/null)"
  local short_sha; short_sha="$(git -C "$wt_path" rev-parse --short HEAD 2>/dev/null)"
  print -r -- "  Commit:   ${C_DIM}$short_sha${C_RESET}"

  local last_msg; last_msg="$(git -C "$wt_path" log -1 --format='%s' 2>/dev/null | cut -c1-60)"
  print -r -- "  Message:  ${C_DIM}$last_msg${C_RESET}"

  local last_date; last_date="$(git -C "$wt_path" log -1 --format='%ar' 2>/dev/null)"
  print -r -- "  Date:     ${C_DIM}$last_date${C_RESET}"

  local author; author="$(git -C "$wt_path" log -1 --format='%an' 2>/dev/null)"
  print -r -- "  Author:   ${C_DIM}$author${C_RESET}"

  # Sync status
  local counts; counts="$(get_ahead_behind "$wt_path" "$DEFAULT_BASE")"
  local ahead="${counts%% *}" behind="${counts##* }"
  print -r -- "  Sync:     ${C_GREEN}â†‘$ahead${C_RESET} ${C_RED}â†“$behind${C_RESET} vs $DEFAULT_BASE"
  print -r -- ""

  # Working tree status
  print -r -- "${C_BOLD}Status${C_RESET}"
  local st; st="$(git -C "$wt_path" status --porcelain 2>/dev/null)"
  if [[ -n "$st" ]]; then
    local changes; changes="$(print -r -- "$st" | wc -l | tr -d ' ')"
    local staged; staged="$(print -r -- "$st" | grep -c '^[MADRC]' || echo 0)"
    local unstaged; unstaged="$(print -r -- "$st" | grep -c '^.[MADRC]' || echo 0)"
    local untracked; untracked="$(print -r -- "$st" | grep -c '^??' || echo 0)"
    print -r -- "  Changes:  ${C_YELLOW}$changes${C_RESET} total"
    print -r -- "  Staged:   ${C_GREEN}$staged${C_RESET}"
    print -r -- "  Modified: ${C_YELLOW}$unstaged${C_RESET}"
    print -r -- "  Untracked: ${C_DIM}$untracked${C_RESET}"
  else
    print -r -- "  Status:   ${C_GREEN}â— Clean${C_RESET}"
  fi
  print -r -- ""

  # Disk usage
  print -r -- "${C_BOLD}Disk Usage${C_RESET}"
  local total_size; total_size="$(du -sh "$wt_path" 2>/dev/null | cut -f1)"
  print -r -- "  Total:        ${C_YELLOW}$total_size${C_RESET}"

  if [[ -d "$wt_path/node_modules" ]]; then
    local nm_size; nm_size="$(du -sh "$wt_path/node_modules" 2>/dev/null | cut -f1)"
    print -r -- "  node_modules: ${C_DIM}$nm_size${C_RESET}"
  fi
  if [[ -d "$wt_path/vendor" ]]; then
    local vendor_size; vendor_size="$(du -sh "$wt_path/vendor" 2>/dev/null | cut -f1)"
    print -r -- "  vendor:       ${C_DIM}$vendor_size${C_RESET}"
  fi
  print -r -- ""

  # Framework detection
  print -r -- "${C_BOLD}Framework${C_RESET}"
  if [[ -f "$wt_path/artisan" ]]; then
    local laravel_version; laravel_version="$(grep -m1 'laravel/framework' "$wt_path/composer.lock" 2>/dev/null | grep -o '"version": "[^"]*"' | cut -d'"' -f4)"
    print -r -- "  Laravel:  ${C_GREEN}$laravel_version${C_RESET}"
  fi
  if [[ -f "$wt_path/package.json" ]]; then
    local node_deps; node_deps="$(jq '.dependencies | length' "$wt_path/package.json" 2>/dev/null || echo "?")"
    print -r -- "  Node:     ${C_DIM}$node_deps dependencies${C_RESET}"
  fi
  print -r -- ""
}

cmd_recent() {
  local limit="${1:-5}"

  print -r -- ""
  print -r -- "${C_BOLD}Recently Accessed Worktrees${C_RESET}"
  print -r -- ""

  # Find all worktrees and sort by access time
  local worktrees=()

  # Declare loop-scoped variables BEFORE the loop to avoid zsh local re-declaration bug
  local repo_name out wt_path line atime
  local entry rest repo folder branch now age age_str

  for git_dir in "$HERD_ROOT"/*.git(N); do
    [[ -d "$git_dir" ]] || continue
    repo_name="${${git_dir:t}%.git}"

    out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || continue
    wt_path=""

    while IFS= read -r line; do
      if [[ "$line" == worktree\ * ]]; then
        wt_path="${line#worktree }"
      elif [[ -z "$line" && -n "$wt_path" && "$wt_path" != *.git && -d "$wt_path" ]]; then
        atime="$(stat -f '%m' "$wt_path" 2>/dev/null || stat -c '%Y' "$wt_path" 2>/dev/null || echo 0)"
        worktrees+=("$atime|$repo_name|$wt_path")
        wt_path=""
      fi
    done <<< "$out"
    # Handle last entry (no trailing newline in porcelain output)
    if [[ -n "$wt_path" && "$wt_path" != *.git && -d "$wt_path" ]]; then
      atime="$(stat -f '%m' "$wt_path" 2>/dev/null || stat -c '%Y' "$wt_path" 2>/dev/null || echo 0)"
      worktrees+=("$atime|$repo_name|$wt_path")
    fi
  done

  if (( ${#worktrees[@]} == 0 )); then
    dim "No worktrees found."
    return 0
  fi

  # Sort by access time (newest first) and show top N
  local sorted
  sorted=($(printf '%s\n' "${worktrees[@]}" | sort -t'|' -k1 -rn | head -n "$limit"))

  local idx=0
  for entry in "${sorted[@]}"; do
    idx=$((idx + 1))
    atime="${entry%%|*}"
    rest="${entry#*|}"
    repo="${rest%%|*}"
    wt_path="${rest#*|}"
    folder="${wt_path:t}"
    branch="${folder#*--}"

    # Format time
    now="$(date +%s)"
    age=$((now - atime))
    if (( age < 3600 )); then
      age_str="$((age / 60))m ago"
    elif (( age < 86400 )); then
      age_str="$((age / 3600))h ago"
    else
      age_str="$((age / 86400))d ago"
    fi

    print -r -- "  ${C_BOLD}[$idx]${C_RESET} ${C_CYAN}$repo${C_RESET} / ${C_MAGENTA}$branch${C_RESET}"
    print -r -- "      ${C_DIM}$age_str${C_RESET}"
  done

  print -r -- ""
  dim "Usage: cd \"\$(wt cd <repo> <branch>)\""
  print -r -- ""
}

cmd_clean() {
  local repo="${1:-}"
  local dry_run="${DRY_RUN:-false}"

  print -r -- ""
  print -r -- "${C_BOLD}Clean Inactive Worktrees${C_RESET}"
  print -r -- ""

  local inactive_days=30
  local total_saved=0
  local cleaned=0

  # Helper to format bytes
  format_size() {
    local bytes="$1"
    if (( bytes >= 1073741824 )); then
      printf "%.1fG" "$((bytes / 1073741824.0))"
    elif (( bytes >= 1048576 )); then
      printf "%.1fM" "$((bytes / 1048576.0))"
    elif (( bytes >= 1024 )); then
      printf "%.1fK" "$((bytes / 1024.0))"
    else
      printf "%dB" "$bytes"
    fi
  }

  process_repo() {
    local repo_name="$1"
    local git_dir; git_dir="$(git_dir_for "$repo_name")"

    local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || return
    local wt_path="" branch="" line=""
    local age_days nm_size vendor_size wt_saved folder nm_human v_human

    while IFS= read -r line; do
      if [[ "$line" == worktree\ * ]]; then
        wt_path="${line#worktree }"
      elif [[ "$line" == branch\ refs/heads/* ]]; then
        branch="${line#branch refs/heads/}"
      elif [[ -z "$line" && -n "$wt_path" && "$wt_path" != *.git ]]; then
        if [[ -d "$wt_path" ]]; then
          age_days="$(get_commit_age_days "$wt_path")"

          if (( age_days > inactive_days )); then
            nm_size=0
            vendor_size=0
            wt_saved=0

            # Check node_modules
            if [[ -d "$wt_path/node_modules" ]]; then
              nm_size="$(du -sk "$wt_path/node_modules" 2>/dev/null | cut -f1)"
              nm_size=$((nm_size * 1024))  # Convert to bytes
            fi

            # Check vendor
            if [[ -d "$wt_path/vendor" ]]; then
              vendor_size="$(du -sk "$wt_path/vendor" 2>/dev/null | cut -f1)"
              vendor_size=$((vendor_size * 1024))
            fi

            wt_saved=$((nm_size + vendor_size))

            if (( wt_saved > 0 )); then
              folder="${wt_path:t}"
              print -r -- "  ${C_CYAN}$repo_name${C_RESET} / ${C_MAGENTA}${folder#*--}${C_RESET}"
              print -r -- "    ${C_DIM}Inactive: ${age_days}d${C_RESET}"

              if (( nm_size > 0 )); then
                nm_human="$(format_size $nm_size)"
                print -r -- "    ${C_DIM}node_modules:${C_RESET} ${C_YELLOW}$nm_human${C_RESET}"
              fi
              if (( vendor_size > 0 )); then
                v_human="$(format_size $vendor_size)"
                print -r -- "    ${C_DIM}vendor:${C_RESET}       ${C_YELLOW}$v_human${C_RESET}"
              fi

              if [[ "$dry_run" != true ]]; then
                [[ -d "$wt_path/node_modules" ]] && rm -rf "$wt_path/node_modules"
                [[ -d "$wt_path/vendor" ]] && rm -rf "$wt_path/vendor"
              fi

              total_saved=$((total_saved + wt_saved))
              cleaned=$((cleaned + 1))
              print -r -- ""
            fi
          fi
        fi
        wt_path=""
        branch=""
      fi
    done <<< "$out"
  }

  # Declare loop-scoped variables
  local repo_name total_human

  if [[ -n "$repo" ]]; then
    validate_name "$repo" "repository"
    process_repo "$repo"
  else
    # Process all repos
    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      repo_name="${${git_dir:t}%.git}"
      process_repo "$repo_name"
    done
  fi

  if (( cleaned == 0 )); then
    ok "No inactive worktrees with cleanable dependencies found"
  else
    total_human="$(format_size $total_saved)"
    if [[ "$dry_run" == true ]]; then
      info "Would clean ${C_BOLD}$cleaned${C_RESET} worktree(s), saving ${C_GREEN}$total_human${C_RESET}"
      dim "  Run without --dry-run to clean"
    else
      ok "Cleaned ${C_BOLD}$cleaned${C_RESET} worktree(s), saved ${C_GREEN}$total_human${C_RESET}"
      dim "  Reinstall with: npm ci / composer install"
    fi
  fi
  print -r -- ""
}

# Alias management
readonly WT_ALIASES_FILE="$HOME/.wt/aliases"

cmd_alias() {
  local action="${1:-}"
  local alias_name="${2:-}"
  local target="${3:-}"

  # Ensure aliases file exists
  [[ -d "${WT_ALIASES_FILE:h}" ]] || mkdir -p "${WT_ALIASES_FILE:h}"
  [[ -f "$WT_ALIASES_FILE" ]] || touch "$WT_ALIASES_FILE"

  case "$action" in
    ""|list)
      print -r -- ""
      print -r -- "${C_BOLD}Branch Aliases${C_RESET}"
      print -r -- ""
      if [[ -s "$WT_ALIASES_FILE" ]]; then
        while IFS='=' read -r name value; do
          [[ -n "$name" && "$name" != \#* ]] && print -r -- "  ${C_GREEN}$name${C_RESET} â†’ ${C_MAGENTA}$value${C_RESET}"
        done < "$WT_ALIASES_FILE"
      else
        dim "  No aliases defined"
      fi
      print -r -- ""
      dim "Usage: wt alias add <name> <repo/branch>"
      dim "       wt alias rm <name>"
      print -r -- ""
      ;;

    add|set)
      [[ -n "$alias_name" && -n "$target" ]] || die "Usage: wt alias add <name> <repo/branch>"

      # Validate alias name (alphanumeric, dash, underscore only)
      if [[ ! "$alias_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        die "Invalid alias name: '$alias_name' (use alphanumeric, dash, underscore)"
      fi

      # Remove existing alias if present
      if grep -q "^${alias_name}=" "$WT_ALIASES_FILE" 2>/dev/null; then
        local temp_file; temp_file="$(mktemp)"
        grep -v "^${alias_name}=" "$WT_ALIASES_FILE" > "$temp_file"
        mv "$temp_file" "$WT_ALIASES_FILE"
      fi

      # Add new alias
      print -r -- "${alias_name}=${target}" >> "$WT_ALIASES_FILE"
      ok "Alias created: ${C_GREEN}$alias_name${C_RESET} â†’ ${C_MAGENTA}$target${C_RESET}"
      ;;

    rm|remove|delete)
      [[ -n "$alias_name" ]] || die "Usage: wt alias rm <name>"

      if grep -q "^${alias_name}=" "$WT_ALIASES_FILE" 2>/dev/null; then
        local temp_file; temp_file="$(mktemp)"
        grep -v "^${alias_name}=" "$WT_ALIASES_FILE" > "$temp_file"
        mv "$temp_file" "$WT_ALIASES_FILE"
        ok "Alias removed: ${C_YELLOW}$alias_name${C_RESET}"
      else
        die "Alias not found: $alias_name"
      fi
      ;;

    *)
      die "Unknown action: $action (try: list, add, rm)"
      ;;
  esac
}

# Resolve alias to repo/branch
resolve_alias() {
  local alias_name="$1"

  if [[ -f "$WT_ALIASES_FILE" ]]; then
    local result; result="$(grep "^${alias_name}=" "$WT_ALIASES_FILE" 2>/dev/null | head -1 | cut -d'=' -f2-)"
    if [[ -n "$result" ]]; then
      print -r -- "$result"
      return 0
    fi
  fi
  return 1
}

# laravel.sh - Laravel-specific commands

cmd_migrate() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt migrate [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"
  [[ -f "$wt_path/artisan" ]] || die "Not a Laravel project (no artisan file)"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"
  php artisan migrate
  popd >/dev/null
}

cmd_tinker() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt tinker [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"
  [[ -f "$wt_path/artisan" ]] || die "Not a Laravel project (no artisan file)"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"
  php artisan tinker
  popd >/dev/null
}

# 99-main.sh - Main entry point, usage, and flag parsing

usage() {
  print -r -- ""
  print -r -- "${C_BOLD}wt${C_RESET} v$VERSION - Git worktree manager for Laravel Herd"
  print -r -- ""
  print -r -- "${C_BOLD}USAGE${C_RESET}"
  print -r -- "  wt [flags] <command> [args]"
  print -r -- ""
  print -r -- "${C_BOLD}CORE COMMANDS${C_RESET}"
  print -r -- "  ${C_GREEN}add${C_RESET}      ${C_DIM}<repo> <branch> [base]${C_RESET}     Create worktree"
  print -r -- "           ${C_DIM}--template=<name>, -t <name>${C_RESET}  Use template"
  print -r -- "           ${C_DIM}--dry-run${C_RESET}                     Preview without creating"
  print -r -- "           ${C_DIM}--interactive, -i${C_RESET}             Guided creation wizard"
  print -r -- "  ${C_GREEN}rm${C_RESET}       ${C_DIM}<repo> [branch]${C_RESET}            Remove worktree"
  print -r -- "  ${C_GREEN}ls${C_RESET}       ${C_DIM}<repo>${C_RESET}                     List worktrees"
  print -r -- "  ${C_GREEN}repos${C_RESET}                               List all repositories"
  print -r -- "  ${C_GREEN}clone${C_RESET}    ${C_DIM}<url> [name] [branch]${C_RESET}      Clone as bare repo"
  print -r -- ""
  print -r -- "${C_BOLD}GIT COMMANDS${C_RESET} ${C_DIM}(auto-detect repo/branch when run from worktree)${C_RESET}"
  print -r -- "  ${C_GREEN}status${C_RESET}   ${C_DIM}<repo>${C_RESET}                     Dashboard view of all worktrees"
  print -r -- "  ${C_GREEN}pull${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Pull latest changes"
  print -r -- "  ${C_GREEN}pull-all${C_RESET} ${C_DIM}<repo>${C_RESET}                     Pull all worktrees (parallel)"
  print -r -- "  ${C_GREEN}sync${C_RESET}     ${C_DIM}[repo] [branch] [base]${C_RESET}     Rebase onto base branch"
  print -r -- "  ${C_GREEN}diff${C_RESET}     ${C_DIM}[repo] [branch] [base]${C_RESET}     Show diff against base branch"
  print -r -- "  ${C_GREEN}log${C_RESET}      ${C_DIM}[repo] [branch]${C_RESET}            Show recent commits"
  print -r -- "  ${C_GREEN}prune${C_RESET}    ${C_DIM}<repo>${C_RESET}                     Clean up stale worktrees"
  print -r -- ""
  print -r -- "${C_BOLD}PARALLEL COMMANDS${C_RESET}"
  print -r -- "  ${C_GREEN}build-all${C_RESET} ${C_DIM}<repo>${C_RESET}                    npm run build on all"
  print -r -- "  ${C_GREEN}exec-all${C_RESET}  ${C_DIM}<repo> <cmd>${C_RESET}              Run command on all"
  print -r -- ""
  print -r -- "${C_BOLD}LARAVEL COMMANDS${C_RESET} ${C_DIM}(auto-detect when run from worktree)${C_RESET}"
  print -r -- "  ${C_GREEN}fresh${C_RESET}    ${C_DIM}[repo] [branch]${C_RESET}            migrate:fresh + npm ci + build"
  print -r -- "  ${C_GREEN}migrate${C_RESET}  ${C_DIM}[repo] [branch]${C_RESET}            Run artisan migrate"
  print -r -- "  ${C_GREEN}tinker${C_RESET}   ${C_DIM}[repo] [branch]${C_RESET}            Run artisan tinker"
  print -r -- ""
  print -r -- "${C_BOLD}NAVIGATION${C_RESET} ${C_DIM}(auto-detect when run from worktree)${C_RESET}"
  print -r -- "  ${C_GREEN}code${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Open in editor"
  print -r -- "  ${C_GREEN}open${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Open URL in browser"
  print -r -- "  ${C_GREEN}cd${C_RESET}       ${C_DIM}[repo] [branch]${C_RESET}            Print worktree path"
  print -r -- "  ${C_GREEN}switch${C_RESET}   ${C_DIM}<repo> [branch]${C_RESET}            cd + code + open in one"
  print -r -- "  ${C_GREEN}exec${C_RESET}     ${C_DIM}<repo> <branch> <cmd>${C_RESET}      Run command in worktree"
  print -r -- ""
  print -r -- "${C_BOLD}UTILITIES${C_RESET}"
  print -r -- "  ${C_GREEN}doctor${C_RESET}                              Check system requirements"
  print -r -- "  ${C_GREEN}health${C_RESET}   ${C_DIM}<repo>${C_RESET}                     Check repository health"
  print -r -- "  ${C_GREEN}info${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Detailed worktree information"
  print -r -- "  ${C_GREEN}recent${C_RESET}   ${C_DIM}[count]${C_RESET}                    List recently accessed worktrees"
  print -r -- "  ${C_GREEN}clean${C_RESET}    ${C_DIM}[repo]${C_RESET}                     Remove deps from inactive worktrees"
  print -r -- "  ${C_GREEN}alias${C_RESET}    ${C_DIM}[add|rm] <name> [target]${C_RESET}   Manage branch aliases"
  print -r -- "  ${C_GREEN}repair${C_RESET}   ${C_DIM}[repo]${C_RESET}                     Fix common issues"
  print -r -- "  ${C_GREEN}upgrade${C_RESET}                             Self-update wt to latest version"
  print -r -- "  ${C_GREEN}report${C_RESET}   ${C_DIM}<repo> [--output <file>]${C_RESET}  Generate markdown status report"
  print -r -- "  ${C_GREEN}cleanup-herd${C_RESET}                        Remove orphaned Herd nginx configs"
  print -r -- "  ${C_GREEN}unlock${C_RESET}   ${C_DIM}[repo]${C_RESET}                    Remove stale git lock files"
  print -r -- ""
  print -r -- "${C_BOLD}FLAGS${C_RESET}"
  print -r -- "  ${C_YELLOW}-q, --quiet${C_RESET}          Suppress informational output"
  print -r -- "  ${C_YELLOW}-f, --force${C_RESET}          Skip confirmations / force protected branch removal"
  print -r -- "  ${C_YELLOW}-i, --interactive${C_RESET}    Launch interactive worktree creation wizard"
  print -r -- "  ${C_YELLOW}--json${C_RESET}               Output in JSON format"
  print -r -- "  ${C_YELLOW}--pretty${C_RESET}             Pretty-print JSON output with colours"
  print -r -- "  ${C_YELLOW}--dry-run${C_RESET}            Preview actions without executing (wt add)"
  print -r -- "  ${C_YELLOW}-t, --template${C_RESET}       Apply template when creating worktree"
  print -r -- "  ${C_YELLOW}--delete-branch${C_RESET}      Delete branch when removing worktree"
  print -r -- "  ${C_YELLOW}--drop-db${C_RESET}            Drop database when removing worktree"
  print -r -- "  ${C_YELLOW}--no-backup${C_RESET}          Skip database backup when removing worktree"
  print -r -- "  ${C_YELLOW}-v, --version${C_RESET}        Show version (add --check to check for updates)"
  print -r -- ""
  print -r -- "${C_BOLD}EXAMPLES${C_RESET}"
  print -r -- "  ${C_DIM}# Set up a new project${C_RESET}"
  print -r -- "  wt clone git@github.com:org/myapp.git"
  print -r -- "  wt add myapp feature/login"
  print -r -- ""
  print -r -- "  ${C_DIM}# Interactive worktree creation${C_RESET}"
  print -r -- "  wt add --interactive"
  print -r -- ""
  print -r -- "  ${C_DIM}# Navigate to worktree${C_RESET}"
  print -r -- "  cd \"\$(wt cd myapp feature/login)\""
  print -r -- ""
  print -r -- "  ${C_DIM}# Interactive selection (requires fzf)${C_RESET}"
  print -r -- "  wt code myapp              ${C_DIM}# opens fzf picker${C_RESET}"
  print -r -- ""
  print -r -- "  ${C_DIM}# Run command in worktree${C_RESET}"
  print -r -- "  wt exec myapp feature/login php artisan migrate"
  print -r -- ""
  print -r -- "  ${C_DIM}# Parallel operations${C_RESET}"
  print -r -- "  wt pull-all myapp          ${C_DIM}# pull all worktrees${C_RESET}"
  print -r -- "  wt build-all myapp         ${C_DIM}# build all worktrees${C_RESET}"
  print -r -- ""
  print -r -- "  ${C_DIM}# Use template with dry-run preview${C_RESET}"
  print -r -- "  wt add myapp feature/api --template=backend --dry-run"
  print -r -- ""
  print -r -- "${C_BOLD}AVAILABLE TEMPLATES${C_RESET}"
  list_templates
  print -r -- ""
  print -r -- "  ${C_DIM}Run 'wt templates' for details or 'wt templates <name>' to view a template${C_RESET}"
  print -r -- ""
  print -r -- "${C_BOLD}ENVIRONMENT${C_RESET}"
  print -r -- "  ${C_YELLOW}HERD_ROOT${C_RESET}         Herd directory ${C_DIM}(default: \$HOME/Herd)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_BASE_DEFAULT${C_RESET}   Default base branch ${C_DIM}(default: origin/staging)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_EDITOR${C_RESET}         Editor command ${C_DIM}(default: cursor)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_CONFIG${C_RESET}         Config file path ${C_DIM}(default: ~/.wtrc)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_URL_SUBDOMAIN${C_RESET}  Optional URL subdomain ${C_DIM}(e.g., api -> api.feature.test)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_HOOKS_DIR${C_RESET}      Hooks directory ${C_DIM}(default: ~/.wt/hooks)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_MAX_PARALLEL${C_RESET}   Max parallel operations ${C_DIM}(default: 4)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_HOST${C_RESET}        MySQL host ${C_DIM}(default: 127.0.0.1)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_USER${C_RESET}        MySQL user ${C_DIM}(default: root)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_PASSWORD${C_RESET}    MySQL password ${C_DIM}(default: empty)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_CREATE${C_RESET}      Auto-create database ${C_DIM}(default: true)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_BACKUP${C_RESET}      Backup database on remove ${C_DIM}(default: true)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_BACKUP_DIR${C_RESET}  Backup directory ${C_DIM}(default: ~/Code/Project Support/...)${C_RESET}"
  print -r -- ""
  print -r -- "${C_BOLD}CONFIG FILE${C_RESET}"
  print -r -- "  Create ${C_CYAN}~/.wtrc${C_RESET} or ${C_CYAN}\$HERD_ROOT/.wtconfig${C_RESET} with:"
  print -r -- "    HERD_ROOT=/path/to/herd"
  print -r -- "    DEFAULT_BASE=origin/main"
  print -r -- "    DEFAULT_EDITOR=code"
  print -r -- "    WT_URL_SUBDOMAIN=api       ${C_DIM}# optional: api.feature.test${C_RESET}"
  print -r -- "    DB_USER=root"
  print -r -- "    DB_PASSWORD=secret"
  print -r -- "    DB_BACKUP_DIR=/path/to/backups"
  print -r -- ""
  print -r -- "${C_BOLD}HOOKS${C_RESET}"
  print -r -- "  Create executable scripts in ${C_CYAN}~/.wt/hooks/${C_RESET} to run custom commands:"
  print -r -- ""
  print -r -- "  ${C_GREEN}pre-add${C_RESET}      Run before worktree creation (can abort)"
  print -r -- "  ${C_GREEN}post-add${C_RESET}     Run after worktree creation"
  print -r -- "  ${C_GREEN}pre-rm${C_RESET}       Run before worktree removal (can abort)"
  print -r -- "  ${C_GREEN}post-rm${C_RESET}      Run after worktree removal"
  print -r -- "  ${C_GREEN}post-pull${C_RESET}    Run after wt pull succeeds"
  print -r -- "  ${C_GREEN}post-sync${C_RESET}    Run after wt sync succeeds"
  print -r -- ""
  print -r -- "  ${C_DIM}Available environment variables in hooks:${C_RESET}"
  print -r -- "    WT_REPO       Repository name"
  print -r -- "    WT_BRANCH     Branch name"
  print -r -- "    WT_PATH       Worktree path"
  print -r -- "    WT_URL        Application URL"
  print -r -- "    WT_DB_NAME    Database name"
  print -r -- ""
  print -r -- "  ${C_DIM}Example ~/.wt/hooks/post-add:${C_RESET}"
  print -r -- "    #!/bin/bash"
  print -r -- "    npm ci && npm run build"
  print -r -- "    php artisan migrate"
  print -r -- ""
  print -r -- "  ${C_DIM}Multiple hooks: Create ~/.wt/hooks/post-add.d/ with numbered scripts${C_RESET}"
  print -r -- "  ${C_DIM}Repo-specific: Create ~/.wt/hooks/post-add.d/<repo>/ for repo-only hooks${C_RESET}"
  print -r -- ""
}

# Parse global flags (can appear anywhere in command line)
parse_flags() {
  REMAINING_ARGS=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -q|--quiet) QUIET=true ;;
      -f|--force) FORCE=true ;;
      -i|--interactive) INTERACTIVE=true ;;
      --json) JSON_OUTPUT=true ;;
      --delete-branch) DELETE_BRANCH=true ;;
      --drop-db) DROP_DB=true ;;
      --no-backup) NO_BACKUP=true ;;
      --dry-run) DRY_RUN=true ;;
      --pretty) PRETTY_JSON=true ;;
      --check) VERSION_CHECK=true ;;
      --all-repos) ALL_REPOS=true ;;
      --template=*)
        WT_TEMPLATE="${1#--template=}"
        if [[ -z "$WT_TEMPLATE" ]]; then
          setup_colors
          die "Template name cannot be empty"
        fi
        ;;
      -t)
        shift
        if [[ -z "${1:-}" || "$1" == -* ]]; then
          setup_colors
          die "Template name required after -t flag"
        fi
        WT_TEMPLATE="$1"
        ;;
      -v|--version)
        if [[ "${VERSION_CHECK:-false}" == true ]]; then
          setup_colors
          cmd_version_check
        else
          print -r -- "wt version $VERSION"
        fi
        exit 0
        ;;
      -h|--help|help) setup_colors; usage; exit 0 ;;
      -*) setup_colors; die "Unknown flag: $1" ;;
      *) REMAINING_ARGS+=("$1") ;;
    esac
    shift
  done
}

main() {
  load_config
  parse_flags "$@"
  setup_colors

  set -- "${REMAINING_ARGS[@]}"

  local cmd="${1:-}"
  shift || true

  # Handle interactive mode for add command
  if [[ "$INTERACTIVE" == true ]]; then
    if [[ -z "$cmd" || "$cmd" == "add" ]]; then
      interactive_add "$@"
      return $?
    fi
  fi

  case "$cmd" in
    add)          cmd_add "$@" ;;
    rm)           cmd_rm "$@" ;;
    ls)           cmd_ls "$@" ;;
    status)       cmd_status "$@" ;;
    pull)         cmd_pull "$@" ;;
    pull-all)     cmd_pull_all "$@" ;;
    sync)         cmd_sync "$@" ;;
    clone)        cmd_clone "$@" ;;
    code)         cmd_code "$@" ;;
    open)         cmd_open "$@" ;;
    cd)           cmd_cd "$@" ;;
    exec)         cmd_exec "$@" ;;
    prune)        cmd_prune "$@" ;;
    repos)        cmd_repos "$@" ;;
    templates)    cmd_templates "$@" ;;
    doctor)       cmd_doctor "$@" ;;
    cleanup-herd) cmd_cleanup_herd "$@" ;;
    unlock)       cmd_unlock "$@" ;;
    fresh)        cmd_fresh "$@" ;;
    build-all)    cmd_build_all "$@" ;;
    exec-all)     cmd_exec_all "$@" ;;
    repair)       cmd_repair "$@" ;;
    switch)       cmd_switch "$@" ;;
    migrate)      cmd_migrate "$@" ;;
    tinker)       cmd_tinker "$@" ;;
    log)          cmd_log "$@" ;;
    diff)         cmd_diff "$@" ;;
    report)       cmd_report "$@" ;;
    health)       cmd_health "$@" ;;
    info)         cmd_info "$@" ;;
    recent)       cmd_recent "$@" ;;
    clean)        cmd_clean "$@" ;;
    alias)        cmd_alias "$@" ;;
    upgrade)      cmd_upgrade "$@" ;;
    dashboard)    cmd_dashboard "$@" ;;
    "")           usage ;;
    *)            die "Unknown command: $cmd (try: wt --help)" ;;
  esac
}

main "$@"
