#!/usr/bin/env zsh
set -euo pipefail

readonly VERSION="3.9.0"

# Defaults (can be overridden by config file or env vars)
HERD_ROOT="${HERD_ROOT:-$HOME/Herd}"
HERD_CONFIG="${HERD_CONFIG:-$HOME/Library/Application Support/Herd/config}"
DEFAULT_BASE="${WT_BASE_DEFAULT:-origin/staging}"
DEFAULT_EDITOR="${WT_EDITOR:-cursor}"

# URL generation defaults
WT_URL_SUBDOMAIN="${WT_URL_SUBDOMAIN:-}"  # Optional subdomain prefix (e.g., "api" -> api.feature-name.test)

# Database defaults
DB_HOST="${WT_DB_HOST:-127.0.0.1}"
DB_USER="${WT_DB_USER:-root}"
DB_PASSWORD="${WT_DB_PASSWORD:-}"
DB_CREATE="${WT_DB_CREATE:-true}"
DB_BACKUP_DIR="${WT_DB_BACKUP_DIR:-$HOME/Code/Project Support/Worktree/Database/Backup}"
DB_BACKUP="${WT_DB_BACKUP:-true}"

# Hooks directory (for custom post-add scripts, etc.)
WT_HOOKS_DIR="${WT_HOOKS_DIR:-$HOME/.wt/hooks}"

# Templates directory (for worktree setup templates)
WT_TEMPLATES_DIR="${WT_TEMPLATES_DIR:-$HOME/.wt/templates}"

# Active template (set via --template flag)
WT_TEMPLATE=""

# Global flags
QUIET=false
FORCE=false
JSON_OUTPUT=false
PRETTY_JSON=false
DRY_RUN=false
DELETE_BRANCH=false
DROP_DB=false
NO_BACKUP=false

# Protected branches (cannot be removed without --force)
PROTECTED_BRANCHES="${WT_PROTECTED_BRANCHES:-staging main master}"

# Colour defaults (will be set properly by setup_colors)
C_RESET="" C_BOLD="" C_DIM="" C_RED="" C_GREEN="" C_YELLOW="" C_BLUE="" C_MAGENTA="" C_CYAN=""

# Load config file safely (key=value parsing, not source)
load_config() {
  # Safe config parser - only allows whitelisted variables
  parse_config_file() {
    local file="$1"
    [[ -f "$file" ]] || return 0

    while IFS='=' read -r key value || [[ -n "$key" ]]; do
      # Skip comments and empty lines
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

      # Trim whitespace from key
      key="${key#"${key%%[![:space:]]*}"}"
      key="${key%"${key##*[![:space:]]}"}"

      # Remove quotes and trailing comments from value
      value="${value#\"}"
      value="${value%\"}"
      value="${value#\'}"
      value="${value%\'}"
      value="${value%%#*}"
      value="${value%"${value##*[![:space:]]}"}"

      # Only set whitelisted variables (security)
      case "$key" in
        HERD_ROOT) HERD_ROOT="$value" ;;
        HERD_CONFIG) HERD_CONFIG="$value" ;;
        DEFAULT_BASE) DEFAULT_BASE="$value" ;;
        DEFAULT_EDITOR) DEFAULT_EDITOR="$value" ;;
        WT_URL_SUBDOMAIN) WT_URL_SUBDOMAIN="$value" ;;
        DB_HOST) DB_HOST="$value" ;;
        DB_USER) DB_USER="$value" ;;
        DB_PASSWORD) DB_PASSWORD="$value" ;;
        DB_CREATE) DB_CREATE="$value" ;;
        DB_BACKUP_DIR) DB_BACKUP_DIR="$value" ;;
        DB_BACKUP) DB_BACKUP="$value" ;;
        WT_HOOKS_DIR) WT_HOOKS_DIR="$value" ;;
        WT_TEMPLATES_DIR) WT_TEMPLATES_DIR="$value" ;;
        PROTECTED_BRANCHES) PROTECTED_BRANCHES="$value" ;;
      esac
    done < "$file"
  }

  local config_file="${WT_CONFIG:-$HOME/.wtrc}"
  parse_config_file "$config_file"
  # Also check HERD_ROOT/.wtconfig
  parse_config_file "$HERD_ROOT/.wtconfig"
}

# Load repo-specific config from bare repo directory
# Called by commands that need repo-specific settings (add, sync, clone)
load_repo_config() {
  local git_dir="$1"
  local repo_config="$git_dir/.wtconfig"

  [[ -f "$repo_config" ]] || return 0

  # Re-use the parse_config_file function from load_config
  while IFS='=' read -r key value || [[ -n "$key" ]]; do
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"
    value="${value#\"}"
    value="${value%\"}"
    value="${value#\'}"
    value="${value%\'}"
    value="${value%%#*}"
    value="${value%"${value##*[![:space:]]}"}"

    case "$key" in
      DEFAULT_BASE) DEFAULT_BASE="$value" ;;
      WT_URL_SUBDOMAIN) WT_URL_SUBDOMAIN="$value" ;;
      PROTECTED_BRANCHES) PROTECTED_BRANCHES="$value" ;;
    esac
  done < "$repo_config"
}

# Colours (disabled if not a tty or JSON output)
setup_colors() {
  if [[ -t 1 ]] && [[ "$JSON_OUTPUT" == false ]]; then
    C_RESET=$'\033[0m'
    C_BOLD=$'\033[1m'
    C_DIM=$'\033[2m'
    C_RED=$'\033[31m'
    C_GREEN=$'\033[32m'
    C_YELLOW=$'\033[33m'
    C_BLUE=$'\033[34m'
    C_MAGENTA=$'\033[35m'
    C_CYAN=$'\033[36m'
  fi
}

die()  { print -r -- "${C_RED}‚úñ ERROR:${C_RESET} $*" >&2; exit 1; }
info() { [[ "$QUIET" == true ]] || print -r -- "${C_BLUE}‚Üí${C_RESET} $*"; }
ok()   { [[ "$QUIET" == true ]] || print -r -- "${C_GREEN}‚úî${C_RESET} $*"; }
warn() { print -r -- "${C_YELLOW}‚ö†${C_RESET} $*"; }
dim()  { [[ "$QUIET" == true ]] || print -r -- "${C_DIM}$*${C_RESET}"; }

# Error helper for worktree not found
die_wt_not_found() {
  local repo="$1" wt_path="$2"
  print -r -- "${C_RED}‚úñ ERROR:${C_RESET} Worktree not found at ${C_CYAN}$wt_path${C_RESET}" >&2
  print -r -- "" >&2
  print -r -- "  ${C_DIM}To see available worktrees, run:${C_RESET}" >&2
  print -r -- "    wt ls $repo" >&2
  print -r -- "" >&2
  exit 1
}

# macOS notification
notify() {
  local title="$1" message="$2"
  if command -v osascript >/dev/null 2>&1; then
    osascript -e "display notification \"$message\" with title \"$title\"" 2>/dev/null || true
  fi
}

# Check if branch is protected
is_protected_branch() {
  local branch="$1"
  local protected
  for protected in ${=PROTECTED_BRANCHES}; do
    [[ "$branch" == "$protected" ]] && return 0
  done
  return 1
}

# Config validation
validate_config() {
  local warnings=0

  # Check HERD_ROOT exists
  if [[ ! -d "$HERD_ROOT" ]]; then
    warn "HERD_ROOT does not exist: $HERD_ROOT"
    warnings=$((warnings + 1))
  fi

  # Check for required tools (only warn, don't fail)
  if ! command -v git >/dev/null 2>&1; then
    warn "git not found in PATH"
    warnings=$((warnings + 1))
  fi

  return $warnings
}

# Common validation helper for identifiers (repos, branches, templates)
# Usage: validate_identifier <value> <type> <allowed_chars_regex> [extra_checks]
# Returns 0 on success, calls die on failure
validate_identifier_common() {
  local input="$1" type="$2"

  # Block empty or whitespace-only
  if [[ -z "$input" || "$input" =~ ^[[:space:]]*$ ]]; then
    die "Invalid $type: name cannot be empty"
  fi

  # Block path traversal
  if [[ "$input" == *".."* ]]; then
    die "Invalid $type: '$input' (path traversal not allowed)"
  fi

  # Block names starting with dash (flag injection)
  if [[ "$input" == -* ]]; then
    die "Invalid $type: '$input' (cannot start with dash)"
  fi
}

validate_name() {
  local input="$1" type="$2"

  validate_identifier_common "$input" "$type"

  # Block absolute paths
  if [[ "$input" == /* ]]; then
    die "Invalid $type name: '$input' (absolute paths not allowed)"
  fi

  # Block hidden path segments
  if [[ "$input" == *"/."* || "$input" == *"/./"* ]]; then
    die "Invalid $type name: '$input' (path traversal not allowed)"
  fi

  # Block reserved git references
  if [[ "$type" == "branch" && "$input" =~ ^(HEAD|refs/|@).*$ ]]; then
    die "Invalid $type name: '$input' (reserved git reference)"
  fi

  # Allow alphanumeric, dash, underscore, forward slash, dot
  if [[ ! "$input" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
    die "Invalid $type name: '$input' (only alphanumeric, dash, underscore, slash, dot allowed)"
  fi

  # Block empty segments in paths
  if [[ "$input" =~ // || "$input" =~ /$ ]]; then
    die "Invalid $type name: '$input' (malformed path)"
  fi
}

sed_inplace() {
  local pattern="$1" file="$2"
  if sed --version 2>&1 | grep -q GNU; then
    sed -i "$pattern" "$file"
  else
    sed -i '' "$pattern" "$file"
  fi
}

slugify_branch() {
  local b="$1"
  print -r -- "${b//\//-}"
}

# Extract feature name from branch (strips prefixes like feature/, bugfix/, etc.)
# e.g., "feature/sms-unsubscribe" -> "sms-unsubscribe"
# e.g., "feature/dh/uat/build-test" -> "build-test" (takes last segment)
# e.g., "staging" -> "staging" (unchanged if no prefix)
extract_feature_name() {
  local branch="$1"
  local result="$branch"

  # If branch contains a slash, extract the last segment
  if [[ "$branch" == */* ]]; then
    result="${branch##*/}"
  fi

  print -r -- "$result"
}

# Check if worktree directory name matches the branch it's on
# Returns: "ok", "skip", or "mismatch|expected_slug" (pipe-separated for mismatch)
check_branch_directory_match() {
  local wt_path="$1"
  local actual_branch="$2"
  local repo="$3"

  # Skip bare repo and main worktree (e.g., scooda for staging)
  local folder="${wt_path:t}"
  if [[ "$folder" != *"--"* ]]; then
    print -r -- "skip"
    return 0
  fi

  # Extract the slug from directory name (part after repo--)
  local dir_slug="${folder#*--}"

  # Slugify the actual branch
  local branch_slug; branch_slug="$(slugify_branch "$actual_branch")"

  if [[ "$dir_slug" != "$branch_slug" ]]; then
    print -r -- "mismatch|$branch_slug"
  else
    print -r -- "ok"
  fi
}

# Look up actual worktree path from git by branch name
# Returns empty string if not found
lookup_wt_path() {
  local repo="$1"
  local branch="$2"
  local git_dir; git_dir="$(git_dir_for "$repo")"

  [[ -d "$git_dir" ]] || return 0

  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || return 0

  local path="" current_branch="" line=""
  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ "$current_branch" == "$branch" && -n "$path" ]]; then
        print -r -- "$path"
        return 0
      fi
      path=""
      current_branch=""
      continue
    fi
    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && current_branch="${line#branch refs/heads/}"
  done <<< "$out"

  # Handle last entry (no trailing blank line)
  if [[ "$current_branch" == "$branch" && -n "$path" ]]; then
    print -r -- "$path"
    return 0
  fi

  return 0
}

# Get worktree path - tries lookup first, falls back to computed path
resolve_wt_path() {
  local repo="$1"
  local branch="$2"

  # First try to look up actual path from git
  local actual_path; actual_path="$(lookup_wt_path "$repo" "$branch")"
  if [[ -n "$actual_path" ]]; then
    print -r -- "$actual_path"
    return 0
  fi

  # Fall back to computed path (for new worktrees)
  wt_path_for "$repo" "$branch"
}

# Auto-detect repo and branch from current directory
# Sets DETECTED_REPO and DETECTED_BRANCH globals
# Returns 0 if detected, 1 if not in a worktree
detect_current_worktree() {
  DETECTED_REPO=""
  DETECTED_BRANCH=""

  # Check if we're in a git directory
  local git_dir; git_dir="$(git rev-parse --git-dir 2>/dev/null)" || return 1

  # Get the worktree root
  local wt_root; wt_root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1

  # Check if the worktree is under HERD_ROOT
  [[ "$wt_root" == "$HERD_ROOT"/* ]] || return 1

  # Get the folder name
  local folder="${wt_root:t}"

  # Try to find the bare repo by checking the git-dir path
  # For worktrees, git-dir is like: /path/to/repo.git/worktrees/worktree-name
  if [[ "$git_dir" == *"/worktrees/"* ]]; then
    # Extract bare repo path
    local bare_repo="${git_dir%/worktrees/*}"
    DETECTED_REPO="${${bare_repo:t}%.git}"
  elif [[ -d "$HERD_ROOT/${folder}.git" ]]; then
    # This is a main worktree (like staging) - folder name matches repo
    DETECTED_REPO="$folder"
  else
    # Try to extract repo from folder name (repo--slug pattern)
    if [[ "$folder" == *"--"* ]]; then
      DETECTED_REPO="${folder%%--*}"
    else
      return 1
    fi
  fi

  # Verify the bare repo exists
  [[ -d "$HERD_ROOT/${DETECTED_REPO}.git" ]] || return 1

  # Get the current branch
  DETECTED_BRANCH="$(git branch --show-current 2>/dev/null)" || return 1
  [[ -n "$DETECTED_BRANCH" ]] || return 1

  return 0
}

# Helper to require repo argument, with auto-detection fallback
require_repo() {
  local repo="$1"
  if [[ -z "$repo" ]]; then
    if detect_current_worktree; then
      print -r -- "$DETECTED_REPO"
      return 0
    fi
    return 1
  fi
  print -r -- "$repo"
}

# Helper to require repo and branch, with auto-detection fallback
require_repo_branch() {
  local repo="$1"
  local branch="$2"

  if [[ -z "$repo" ]]; then
    if detect_current_worktree; then
      print -r -- "$DETECTED_REPO $DETECTED_BRANCH"
      return 0
    fi
    return 1
  fi

  if [[ -z "$branch" ]]; then
    # Repo provided but no branch - use fzf or fail
    return 1
  fi

  print -r -- "$repo $branch"
}

git_dir_for() {
  local repo="$1"
  print -r -- "$HERD_ROOT/${repo}.git"
}

wt_path_for() {
  local repo="$1"
  local branch="$2"
  local slug; slug="$(slugify_branch "$branch")"
  print -r -- "$HERD_ROOT/${repo}--${slug}"
}

url_for() {
  local repo="$1"
  local branch="$2"
  local slug; slug="$(slugify_branch "$branch")"
  local site_name="${repo}--${slug}"

  # Build URL: [subdomain.]site-name.test
  # Site name matches the directory name used by Herd
  if [[ -n "$WT_URL_SUBDOMAIN" ]]; then
    print -r -- "https://${WT_URL_SUBDOMAIN}.${site_name}.test"
  else
    print -r -- "https://${site_name}.test"
  fi
}

db_name_for() {
  local repo="$1"
  local branch="$2"
  local slug; slug="$(slugify_branch "$branch")"
  # Replace dashes with underscores for MySQL compatibility
  local db_name="${repo}__${slug}"
  db_name="${db_name//-/_}"

  # MySQL database name limit is 64 characters
  if (( ${#db_name} > 64 )); then
    # Truncate and add hash suffix for uniqueness
    local hash; hash="$(print -r -- "$slug" | md5 | cut -c1-8)"
    local max_repo_len=$((64 - 11))  # Leave room for __<8-char-hash>
    local truncated_repo="${repo:0:$max_repo_len}"
    db_name="${truncated_repo}__${hash}"
    db_name="${db_name//-/_}"
  fi

  print -r -- "$db_name"
}

create_database() {
  local db_name="$1"

  if [[ "$DB_CREATE" != "true" ]]; then
    dim "  üí° Database creation disabled (WT_DB_CREATE=false)"
    return 0
  fi

  if ! command -v mysql >/dev/null 2>&1; then
    warn "MySQL client not found - skipping database creation"
    dim "  üí° Create manually: CREATE DATABASE \`$db_name\`;"
    return 0
  fi

  local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysql_cmd+=(-p"$DB_PASSWORD")
  fi

  info "Creating database ${C_CYAN}$db_name${C_RESET}"

  if "${mysql_cmd[@]}" -e "CREATE DATABASE IF NOT EXISTS \`$db_name\`;" 2>/dev/null; then
    ok "Database created: $db_name"
    return 0
  else
    warn "Could not create database - check MySQL connection"
    dim "  üí° Create manually: CREATE DATABASE \`$db_name\`;"
    return 1
  fi
}

backup_database() {
  local db_name="$1"
  local repo="$2"

  if [[ "$DB_BACKUP" != "true" ]]; then
    dim "  üí° Database backup disabled (WT_DB_BACKUP=false)"
    return 0
  fi

  if ! command -v mysqldump >/dev/null 2>&1; then
    warn "mysqldump not found - skipping database backup"
    return 0
  fi

  # Check if database exists
  local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysql_cmd+=(-p"$DB_PASSWORD")
  fi

  if ! "${mysql_cmd[@]}" -e "USE \`$db_name\`;" 2>/dev/null; then
    dim "  üí° Database $db_name does not exist - skipping backup"
    return 0
  fi

  # Create backup directory
  local backup_dir="$DB_BACKUP_DIR/$repo"
  mkdir -p "$backup_dir" || { warn "Could not create backup directory: $backup_dir"; return 1; }

  # Generate backup filename with timestamp
  local timestamp; timestamp="$(date +%Y%m%d_%H%M%S)"
  local backup_file="$backup_dir/${db_name}_${timestamp}.sql"

  local mysqldump_cmd=(mysqldump -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysqldump_cmd+=(-p"$DB_PASSWORD")
  fi

  info "Backing up database ${C_CYAN}$db_name${C_RESET}"

  if "${mysqldump_cmd[@]}" "$db_name" > "$backup_file" 2>/dev/null; then
    ok "Database backed up: ${C_DIM}$backup_file${C_RESET}"
    return 0
  else
    warn "Could not backup database"
    rm -f "$backup_file" 2>/dev/null
    return 1
  fi
}

drop_database() {
  local db_name="$1"

  if ! command -v mysql >/dev/null 2>&1; then
    warn "MySQL client not found - cannot drop database"
    return 1
  fi

  local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
  if [[ -n "$DB_PASSWORD" ]]; then
    mysql_cmd+=(-p"$DB_PASSWORD")
  fi

  # Check if database exists
  if ! "${mysql_cmd[@]}" -e "USE \`$db_name\`;" 2>/dev/null; then
    dim "  üí° Database $db_name does not exist"
    return 0
  fi

  info "Dropping database ${C_CYAN}$db_name${C_RESET}"

  if "${mysql_cmd[@]}" -e "DROP DATABASE \`$db_name\`;" 2>/dev/null; then
    ok "Database dropped: $db_name"
    return 0
  else
    warn "Could not drop database"
    return 1
  fi
}

unsecure_site() {
  local site_name="$1"

  if ! command -v herd >/dev/null 2>&1; then
    return 0
  fi

  info "Unsecuring site ${C_CYAN}$site_name${C_RESET}"
  if herd unsecure "$site_name" >/dev/null 2>&1; then
    ok "Site unsecured"
  else
    # Site might not be secured, which is fine
    dim "  üí° Site was not secured or already unsecured"
  fi

  # Clean up Herd nginx configs and certificates to prevent stale config issues
  cleanup_herd_site "$site_name"
}

# Remove stale Herd nginx configs and certificates for a site
# This prevents nginx from failing to start due to missing certificate files
cleanup_herd_site() {
  local site_name="$1"
  local site_domain="${site_name}.test"
  local nginx_config="$HERD_CONFIG/valet/Nginx/$site_domain"
  local cert_dir="$HERD_CONFIG/valet/Certificates"
  local cleaned=false

  # Remove nginx config if it exists
  if [[ -f "$nginx_config" ]]; then
    /bin/rm -f "$nginx_config" 2>/dev/null && cleaned=true
  fi

  # Remove certificate files (crt, key, csr, conf)
  for ext in crt key csr conf; do
    local cert_file="$cert_dir/${site_domain}.${ext}"
    if [[ -f "$cert_file" ]]; then
      /bin/rm -f "$cert_file" 2>/dev/null && cleaned=true
    fi
  done

  if [[ "$cleaned" == true ]]; then
    dim "  üí° Cleaned up Herd nginx config and certificates"
  fi
}

ensure_bare_repo() {
  local git_dir="$1"
  [[ -d "$git_dir" ]] || die "Bare repo not found at $git_dir"
}

# List all repos in HERD_ROOT
list_repos() {
  for dir in "$HERD_ROOT"/*.git(N); do
    [[ -d "$dir" ]] && print -r -- "${${dir:t}%.git}"
  done
}

# List all worktree branches for a repo
list_worktree_branches() {
  local repo="$1"
  local git_dir; git_dir="$(git_dir_for "$repo")"
  [[ -d "$git_dir" ]] || return 0

  git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null | \
    grep '^branch refs/heads/' | \
    sed 's|^branch refs/heads/||'
}

# Interactive branch selection with fzf
select_branch_fzf() {
  local repo="$1" prompt="${2:-Select branch}"
  local git_dir; git_dir="$(git_dir_for "$repo")"

  if ! command -v fzf >/dev/null 2>&1; then
    die "fzf not installed. Install with: brew install fzf"
  fi

  local branches; branches="$(list_worktree_branches "$repo")"
  [[ -n "$branches" ]] || die "No worktrees found for $repo"

  print -r -- "$branches" | fzf --prompt="$prompt: " --height=40% --reverse
}

# Get ahead/behind counts for a branch
get_ahead_behind() {
  local wt_path="$1" base="${2:-origin/staging}"
  local ahead=0 behind=0

  if git -C "$wt_path" rev-parse --verify "$base" >/dev/null 2>&1; then
    local counts; counts="$(git -C "$wt_path" rev-list --left-right --count HEAD..."$base" 2>/dev/null)" || counts="0	0"
    ahead="${counts%%	*}"
    behind="${counts##*	}"
  fi

  print -r -- "$ahead $behind"
}

# Check if branch is stale (significantly behind base)
check_stale() {
  local wt_path="$1" base="${2:-origin/staging}" threshold="${3:-50}"
  local counts; counts="$(get_ahead_behind "$wt_path" "$base")"
  local behind="${counts##* }"

  if (( behind > threshold )); then
    warn "Branch is ${C_BOLD}$behind${C_RESET}${C_YELLOW} commits behind ${C_DIM}$base${C_RESET}"
    return 0
  fi
  return 1
}

# Get human-readable age of last commit
# Returns: "1d", "2w", "3mo", "1y" etc.
get_last_commit_age() {
  local wt_path="$1"
  local now epoch_seconds age_seconds age_days

  now="$(date +%s)"
  epoch_seconds="$(git -C "$wt_path" log -1 --format=%ct 2>/dev/null)" || { print -r -- "?"; return 0; }

  # Handle future timestamps (clock skew, timezone issues)
  if (( epoch_seconds > now )); then
    print -r -- "<1h"
    return 0
  fi

  (( age_seconds = now - epoch_seconds ))
  (( age_days = age_seconds / 86400 ))

  if (( age_days == 0 )); then
    local hours=$(( age_seconds / 3600 ))
    if (( hours == 0 )); then
      print -r -- "<1h"
    else
      print -r -- "${hours}h"
    fi
  elif (( age_days < 7 )); then
    print -r -- "${age_days}d"
  elif (( age_days < 30 )); then
    print -r -- "$(( age_days / 7 ))w"
  elif (( age_days < 365 )); then
    print -r -- "$(( age_days / 30 ))mo"
  else
    print -r -- "$(( age_days / 365 ))y"
  fi
}

# Get age in days (for threshold comparison)
get_commit_age_days() {
  local wt_path="$1"
  local now epoch_seconds age_seconds

  now="$(date +%s)"
  epoch_seconds="$(git -C "$wt_path" log -1 --format=%ct 2>/dev/null)" || { print -r -- "0"; return 0; }

  # Handle future timestamps (clock skew, timezone issues)
  if (( epoch_seconds > now )); then
    print -r -- "0"
    return 0
  fi

  (( age_seconds = now - epoch_seconds ))
  print -r -- "$(( age_seconds / 86400 ))"
}

# Check if branch is fully merged into base
is_branch_merged() {
  local wt_path="$1" base="${2:-origin/staging}"
  local branch_head base_head

  branch_head="$(git -C "$wt_path" rev-parse HEAD 2>/dev/null)" || return 1

  # Check if the base branch contains this commit
  if git -C "$wt_path" merge-base --is-ancestor "$branch_head" "$base" 2>/dev/null; then
    return 0
  fi
  return 1
}

# Validate template name (security: prevent path traversal)
validate_template_name() {
  local name="$1"

  validate_identifier_common "$name" "template"

  # Block slashes and backslashes (templates are single files, no paths)
  if [[ "$name" == *"/"* || "$name" == *"\\"* ]]; then
    die "Invalid template name: '$name' (path separators not allowed)"
  fi

  # Only allow alphanumeric, dash, underscore (stricter than repo/branch names)
  if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    die "Invalid template name: '$name' (only alphanumeric, dash, underscore allowed)"
  fi
}

# Load a template file and export its WT_SKIP_* variables
# Template format: key=value (like .wtrc)
# Find similar names for "did you mean?" suggestions
# Usage: suggest_similar <input> <type> <list_of_options>
# Returns the closest match or empty string
suggest_similar() {
  local input="$1" type="$2"
  shift 2
  local options=("$@")
  local best_match="" best_score=999

  for opt in "${options[@]}"; do
    # Simple similarity: count matching characters at start
    local i=0 score=0
    local input_lower="${input:l}" opt_lower="${opt:l}"

    # Check if input is a prefix
    if [[ "$opt_lower" == "$input_lower"* ]]; then
      score=$((${#opt} - ${#input}))
      if (( score < best_score )); then
        best_score=$score
        best_match="$opt"
      fi
      continue
    fi

    # Check if input is a substring
    if [[ "$opt_lower" == *"$input_lower"* ]]; then
      score=$((${#opt} - ${#input} + 5))
      if (( score < best_score )); then
        best_score=$score
        best_match="$opt"
      fi
      continue
    fi

    # Levenshtein-like: count character differences (simplified)
    local len1=${#input_lower} len2=${#opt_lower}
    local max_len=$(( len1 > len2 ? len1 : len2 ))
    local matching=0
    for (( i=0; i < max_len; i++ )); do
      [[ "${input_lower:$i:1}" == "${opt_lower:$i:1}" ]] && ((matching++))
    done
    score=$((max_len - matching))
    if (( score < best_score && score < max_len / 2 )); then
      best_score=$score
      best_match="$opt"
    fi
  done

  # Only suggest if reasonably close (within half the length)
  if [[ -n "$best_match" && $best_score -lt ${#input} ]]; then
    print -r -- "$best_match"
  fi
}

# Get list of available template names
get_template_names() {
  local templates=()
  if [[ -d "$WT_TEMPLATES_DIR" ]]; then
    for f in "$WT_TEMPLATES_DIR"/*.conf(N); do
      templates+=("${f:t:r}")
    done
  fi
  print -r -- "${templates[@]}"
}

load_template() {
  local template_name="$1"

  # Validate template name first (security: prevent path traversal)
  validate_template_name "$template_name"

  local template_file="$WT_TEMPLATES_DIR/${template_name}.conf"

  # Check if template exists
  if [[ ! -f "$template_file" ]]; then
    local available_templates
    available_templates=($(get_template_names))

    local suggestion=""
    if (( ${#available_templates[@]} > 0 )); then
      suggestion="$(suggest_similar "$template_name" "template" "${available_templates[@]}")"
    fi

    local error_msg="Template not found: ${C_CYAN}$template_name${C_RESET}"
    if [[ -n "$suggestion" ]]; then
      error_msg+="\n\n  ${C_YELLOW}Did you mean:${C_RESET} ${C_GREEN}$suggestion${C_RESET}?"
    fi
    error_msg+="\n\n${C_DIM}Available templates:${C_RESET}\n$(list_templates 2>&1)"
    error_msg+="\n\n${C_DIM}Run 'wt templates' to see all templates${C_RESET}"

    die "$error_msg"
  fi

  # Parse template file (only allow WT_SKIP_* and TEMPLATE_DESC)
  while IFS='=' read -r key value || [[ -n "$key" ]]; do
    # Skip comments and empty lines
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

    # Trim whitespace from key
    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"

    # Remove quotes and trailing comments from value
    value="${value#\"}"
    value="${value%\"}"
    value="${value#\'}"
    value="${value%\'}"
    value="${value%%#*}"
    value="${value%"${value##*[![:space:]]}"}"

    # Only allow WT_SKIP_* variables with true/false values (security)
    case "$key" in
      WT_SKIP_*)
        # Security: Only allow true/false values to prevent command injection
        if [[ "$value" != "true" && "$value" != "false" ]]; then
          warn "Invalid value for $key: '$value' (must be true or false) - skipping"
          continue
        fi
        export "$key"="$value"
        ;;
      TEMPLATE_DESC) ;; # Ignore, used for display only
      *) ;; # Ignore other variables (security)
    esac
  done < "$template_file"

  dim "  üìã Applied template: $template_name"
}

# List available templates
list_templates() {
  local templates_found=false

  if [[ -d "$WT_TEMPLATES_DIR" ]]; then
    for f in "$WT_TEMPLATES_DIR"/*.conf(N); do
      templates_found=true
      local name="${f:t:r}"  # Remove path and .conf extension
      local desc=""

      # Extract TEMPLATE_DESC if present
      desc="$(grep '^TEMPLATE_DESC=' "$f" 2>/dev/null | head -1 | cut -d= -f2- | tr -d '"'"'")"

      if [[ -n "$desc" ]]; then
        print -r -- "  $name - $desc"
      else
        print -r -- "  $name"
      fi
    done
  fi

  if [[ "$templates_found" != true ]]; then
    print -r -- "  (no templates found)"
    print -r -- ""
    print -r -- "  Create templates in: $WT_TEMPLATES_DIR/"
    print -r -- "  Example: $WT_TEMPLATES_DIR/laravel.conf"
  fi
}

# JSON helper
json_escape() {
  local s="$1"
  s="${s//\\/\\\\}"       # Backslash must be first
  s="${s//\"/\\\"}"       # Double quote
  s="${s//$'\n'/\\n}"     # Newline
  s="${s//$'\t'/\\t}"     # Tab
  s="${s//$'\r'/\\r}"     # Carriage return
  s="${s//$'\f'/\\f}"     # Form feed
  s="${s//$'\b'/\\b}"     # Backspace
  print -r -- "$s"
}

# Pretty-print JSON with colours and indentation
# Usage: format_json "$json_string"
format_json() {
  local json="$1"

  if [[ "$PRETTY_JSON" != true ]]; then
    print -r -- "$json"
    return
  fi

  # Use sed for basic pretty-printing with colour codes
  # Keys in cyan, strings in green, numbers in yellow, booleans in magenta, brackets in white
  local result="$json"

  # Add newlines and indentation
  result="${result//\[/$'\n['}"
  result="${result//\{/$'\n  {'}"
  result="${result//\}/$'}\n'}"
  result="${result//\],/$'],\n'}"
  result="${result//\}, /'},\n  '}"

  # Apply colours if terminal supports it
  if [[ -t 1 ]]; then
    # Colour keys (words before colons)
    result="$(print -r -- "$result" | sed -E "s/\"([^\"]+)\":/\"${C_CYAN}\1${C_RESET}\":/g")"
    # Colour string values
    result="$(print -r -- "$result" | sed -E "s/: \"([^\"]*)\"/: \"${C_GREEN}\1${C_RESET}\"/g")"
    # Colour booleans
    result="${result//: true/: ${C_MAGENTA}true${C_RESET}}"
    result="${result//: false/: ${C_MAGENTA}false${C_RESET}}"
    # Colour numbers (simple approach)
    result="$(print -r -- "$result" | sed -E "s/: ([0-9]+)([,}])/: ${C_YELLOW}\1${C_RESET}\2/g")"
  fi

  print -r -- "$result"
}

# Verify hook file is safe to execute (owned by current user, not world-writable)
verify_hook_security() {
  local hook_file="$1"
  local current_uid; current_uid="$(id -u)"

  # Check ownership (macOS stat format)
  local file_owner; file_owner="$(stat -f %u "$hook_file" 2>/dev/null)"
  if [[ "$file_owner" != "$current_uid" ]]; then
    warn "Hook '$hook_file' is not owned by current user - skipping for security"
    return 1
  fi

  # Check for world-writable (macOS: last digit of octal perms)
  local file_perms; file_perms="$(stat -f %Lp "$hook_file" 2>/dev/null)"
  if [[ "${file_perms: -1}" =~ [2367] ]]; then
    warn "Hook '$hook_file' is world-writable - skipping for security"
    return 1
  fi

  return 0
}

# Run hooks for a given event
# Usage: run_hooks <hook_name> <repo> <branch> <wt_path> <app_url> <db_name>
# Example: run_hooks "post-add" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"
run_hooks() {
  local hook_name="$1"
  local repo="$2"
  local branch="$3"
  local wt_path="$4"
  local app_url="$5"
  local db_name="$6"

  # Check if hooks directory exists
  [[ -d "$WT_HOOKS_DIR" ]] || return 0

  local hook_file="$WT_HOOKS_DIR/$hook_name"

  # Check if hook exists and is executable
  if [[ -x "$hook_file" ]]; then
    # Security check before executing
    if ! verify_hook_security "$hook_file"; then
      return 0
    fi

    info "Running ${C_CYAN}$hook_name${C_RESET} hook..."

    # Export environment variables for the hook
    (
      export WT_REPO="$repo"
      export WT_BRANCH="$branch"
      export WT_PATH="$wt_path"
      export WT_URL="$app_url"
      export WT_DB_NAME="$db_name"
      export WT_HOOK_NAME="$hook_name"
      # Control flags for hooks
      [[ "$NO_BACKUP" == true ]] && export WT_NO_BACKUP="true"
      [[ "$DROP_DB" == true ]] && export WT_DROP_DB="true"

      # Run hook from the worktree directory
      cd "$wt_path" 2>/dev/null || cd "$HOME"

      if "$hook_file"; then
        ok "Hook ${C_CYAN}$hook_name${C_RESET} completed"
      else
        warn "Hook ${C_CYAN}$hook_name${C_RESET} exited with non-zero status"
      fi
    )
  elif [[ -f "$hook_file" ]]; then
    dim "  üí° Hook $hook_name exists but is not executable. Run: chmod +x $hook_file"
  fi

  # Also check for numbered hooks (post-add.d/*.sh pattern for multiple hooks)
  local hooks_d="$WT_HOOKS_DIR/${hook_name}.d"
  if [[ -d "$hooks_d" ]]; then
    # Run global hooks (files only, not directories)
    for hook_script in "$hooks_d"/*(N.x); do
      # Security check before executing
      if ! verify_hook_security "$hook_script"; then
        continue
      fi

      local script_name="${hook_script:t}"
      info "Running ${C_CYAN}$hook_name.d/$script_name${C_RESET}..."

      (
        export WT_REPO="$repo"
        export WT_BRANCH="$branch"
        export WT_PATH="$wt_path"
        export WT_URL="$app_url"
        export WT_DB_NAME="$db_name"
        export WT_HOOK_NAME="$hook_name"
        [[ "$NO_BACKUP" == true ]] && export WT_NO_BACKUP="true"
        [[ "$DROP_DB" == true ]] && export WT_DROP_DB="true"

        cd "$wt_path" 2>/dev/null || cd "$HOME"

        if "$hook_script"; then
          ok "  $script_name completed"
        else
          warn "  $script_name exited with non-zero status"
        fi
      )
    done

    # Run repo-specific hooks (from subdirectory matching repo name)
    local repo_hooks_d="$hooks_d/$repo"
    if [[ -d "$repo_hooks_d" ]]; then
      for hook_script in "$repo_hooks_d"/*(N.x); do
        # Security check before executing
        if ! verify_hook_security "$hook_script"; then
          continue
        fi

        local script_name="${hook_script:t}"
        info "Running ${C_CYAN}$hook_name.d/$repo/$script_name${C_RESET}..."

        (
          export WT_REPO="$repo"
          export WT_BRANCH="$branch"
          export WT_PATH="$wt_path"
          export WT_URL="$app_url"
          export WT_DB_NAME="$db_name"
          export WT_HOOK_NAME="$hook_name"
          [[ "$NO_BACKUP" == true ]] && export WT_NO_BACKUP="true"
          [[ "$DROP_DB" == true ]] && export WT_DROP_DB="true"

          cd "$wt_path" 2>/dev/null || cd "$HOME"

          if "$hook_script"; then
            ok "  $repo/$script_name completed"
          else
            warn "  $repo/$script_name exited with non-zero status"
          fi
        )
      done
    fi
  fi

  return 0
}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# COMMANDS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

cmd_add() {
  local repo="${1:-}"; local branch="${2:-}"; local base="${3:-}"
  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt add <repo> <branch> [base]"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  # Load repo-specific config (may override DEFAULT_BASE)
  load_repo_config "$git_dir"

  # Load template if specified (sets WT_SKIP_* environment variables)
  if [[ -n "$WT_TEMPLATE" ]]; then
    load_template "$WT_TEMPLATE"
  fi

  # Use provided base or default
  [[ -z "$base" ]] && base="$DEFAULT_BASE"

  local wt_path; wt_path="$(wt_path_for "$repo" "$branch")"
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"

  # Dry-run mode - show what would happen without executing
  if [[ "$DRY_RUN" == true ]]; then
    print -r -- ""
    print -r -- "${C_BOLD}üîç Dry Run Preview${C_RESET}"
    print -r -- ""
    print -r -- "${C_BOLD}Worktree Details:${C_RESET}"
    print -r -- "  Repository:  ${C_CYAN}$repo${C_RESET}"
    print -r -- "  Branch:      ${C_MAGENTA}$branch${C_RESET}"
    print -r -- "  Base:        ${C_DIM}$base${C_RESET}"
    print -r -- "  Path:        $wt_path"
    print -r -- "  URL:         ${C_CYAN}$app_url${C_RESET}"
    print -r -- "  Database:    ${C_CYAN}$db_name${C_RESET}"
    print -r -- ""
    if [[ -n "$WT_TEMPLATE" ]]; then
      print -r -- "${C_BOLD}Template:${C_RESET} $WT_TEMPLATE"
      print -r -- "  ${C_DIM}WT_SKIP_DB${C_RESET}=${WT_SKIP_DB:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_COMPOSER${C_RESET}=${WT_SKIP_COMPOSER:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_NPM${C_RESET}=${WT_SKIP_NPM:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_BUILD${C_RESET}=${WT_SKIP_BUILD:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_MIGRATE${C_RESET}=${WT_SKIP_MIGRATE:-false}"
      print -r -- "  ${C_DIM}WT_SKIP_HERD${C_RESET}=${WT_SKIP_HERD:-false}"
      print -r -- ""
    fi
    print -r -- "${C_BOLD}Actions:${C_RESET}"
    print -r -- "  1. Fetch latest branches from remote"
    if git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch" 2>/dev/null; then
      print -r -- "  2. Create worktree from existing branch: $branch"
    else
      print -r -- "  2. Create new branch '$branch' from '$base'"
      print -r -- "  3. Push branch to remote and set up tracking"
    fi
    print -r -- "  4. Run pre-add hooks"
    print -r -- "  5. Run post-add hooks (environment setup)"
    print -r -- ""
    print -r -- "${C_DIM}Run without --dry-run to execute${C_RESET}"
    return 0
  fi

  info "Fetching latest branches..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  # If base is a remote ref (origin/...), explicitly fetch it to ensure we have the latest
  # This handles branches with slashes and ensures the tracking ref is up-to-date
  if [[ "$base" == origin/* ]]; then
    local remote_branch="${base#origin/}"
    dim "  Fetching latest: $remote_branch"
    git --git-dir="$git_dir" fetch origin "$remote_branch:refs/remotes/origin/$remote_branch" --force 2>/dev/null || true
  fi

  [[ ! -d "$wt_path" ]] || die "Worktree already exists at ${C_CYAN}$wt_path${C_RESET}"

  # Verify base branch exists when creating new branch
  if ! git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch"; then
    if ! git --git-dir="$git_dir" rev-parse --verify "$base" >/dev/null 2>&1; then
      die "Base branch '$base' not found. Run: git --git-dir=\"$git_dir\" branch -a"
    fi
  fi

  # Run pre-add hooks (can abort by returning non-zero)
  if ! run_hooks "pre-add" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"; then
    die "Pre-add hook failed - aborting"
  fi

  # Setup cleanup trap for failed operations
  local cleanup_needed=true
  trap '[[ "$cleanup_needed" == true ]] && { warn "Cleaning up failed worktree..."; git --git-dir="$git_dir" worktree remove --force "$wt_path" 2>/dev/null; }' EXIT

  if git --git-dir="$git_dir" show-ref --quiet "refs/heads/$branch"; then
    info "Creating worktree from existing branch: ${C_MAGENTA}$branch${C_RESET}"
    git --git-dir="$git_dir" worktree add "$wt_path" "$branch"
  else
    info "Creating branch ${C_MAGENTA}$branch${C_RESET} from ${C_DIM}$base${C_RESET}"
    # Use --no-track to prevent auto-tracking the base branch
    git --git-dir="$git_dir" worktree add --no-track -b "$branch" "$wt_path" "$base"
  fi

  # Set up proper remote tracking for the branch (track its own remote, not the base)
  # Push to create remote branch and set tracking in one step
  info "Setting up remote tracking for ${C_MAGENTA}$branch${C_RESET}"
  if GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git -C "$wt_path" push -u origin "$branch:$branch" 2>/dev/null; then
    ok "Remote branch created and tracking set"
  else
    dim "  üí° Push failed (may need to push manually later): git push -u origin $branch"
  fi

  # Success - disable cleanup trap
  cleanup_needed=false
  trap - EXIT

  # Run post-add hooks (handles .env, database, composer, npm, etc.)
  # See ~/.wt/hooks/post-add.d/ for customisation
  run_hooks "post-add" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"

  if [[ "$JSON_OUTPUT" == true ]]; then
    print -r -- "{\"path\": \"$(json_escape "$wt_path")\", \"url\": \"$(json_escape "$app_url")\", \"branch\": \"$(json_escape "$branch")\", \"database\": \"$(json_escape "$db_name")\"}"
  else
    print -r -- ""
    ok "${C_BOLD}Worktree ready${C_RESET}"
    print -r -- "   ${C_DIM}Path${C_RESET}  $wt_path"
    print -r -- "   ${C_DIM}URL${C_RESET}   ${C_CYAN}$app_url${C_RESET}"
    print -r -- "   ${C_DIM}DB${C_RESET}    ${C_CYAN}$db_name${C_RESET}"
    print -r -- ""
  fi
}

cmd_rm() {
  local repo="${1:-}"; local branch="${2:-}"

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to remove")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt rm [-f] [--delete-branch] <repo> <branch>"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  local site_name="${wt_path:t}"

  ensure_bare_repo "$git_dir"
  [[ -d "$wt_path" ]] || die "Worktree not found at $wt_path"

  # Branch protection check
  if is_protected_branch "$branch" && [[ "$FORCE" == false ]]; then
    die "Branch '$branch' is protected. Use -f to force removal."
  fi

  # Check for uncommitted changes and confirm (unless --force)
  if [[ "$FORCE" == false ]]; then
    local wt_status; wt_status="$(git -C "$wt_path" status --porcelain 2>/dev/null)" || wt_status=""
    if [[ -n "$wt_status" ]]; then
      local changes; changes="$(print -r -- "$wt_status" | wc -l | tr -d ' ')"
      warn "Worktree has ${C_BOLD}$changes${C_RESET}${C_YELLOW} uncommitted change(s):${C_RESET}"
      git -C "$wt_path" status --short
      print -n "${C_YELLOW}Continue with removal? [y/N]${C_RESET} "
      local response
      read -r response
      [[ "$response" =~ ^[Yy]$ ]] || die "Aborted"
    fi
  fi

  # Run pre-rm hooks (can abort by returning non-zero)
  # Database backup is handled by pre-rm hooks - see ~/.wt/hooks/pre-rm.d/
  if ! run_hooks "pre-rm" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"; then
    die "Pre-rm hook failed - aborting"
  fi

  info "Removing worktree ${C_CYAN}$wt_path${C_RESET}"
  if [[ "$FORCE" == true ]]; then
    git --git-dir="$git_dir" worktree remove --force "$wt_path"
  else
    git --git-dir="$git_dir" worktree remove "$wt_path"
  fi

  # Delete branch if requested
  if [[ "$DELETE_BRANCH" == true ]]; then
    info "Deleting branch ${C_MAGENTA}$branch${C_RESET}"
    git --git-dir="$git_dir" branch -D "$branch" 2>/dev/null || warn "Could not delete branch (may not exist locally)"
  fi

  info "Pruning stale worktrees..."
  git --git-dir="$git_dir" worktree prune

  # Run post-rm hooks (handles Herd unsecure, database drop, etc.)
  # See ~/.wt/hooks/post-rm.d/ for customisation
  run_hooks "post-rm" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"

  ok "Worktree removed"
  print -r -- ""
}

cmd_ls() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt ls [--json] <repo>"

  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  local json_items=()

  display_worktree() {
    local idx="$1" path="$2" branch="$3" head="$4"
    local folder="${path:t}"
    # Read APP_URL from .env if available, otherwise fall back to folder-based URL
    local url
    if [[ -f "$path/.env" ]]; then
      url="$(grep -E '^APP_URL=' "$path/.env" 2>/dev/null | head -1 | cut -d'=' -f2- | sed 's/#.*//' | tr -d '"' | tr -d "'" | tr -d ' ')"
    fi
    [[ -z "$url" ]] && url="https://${folder}.test"
    local sha; sha="$(git -C "$path" rev-parse --short HEAD 2>/dev/null || true)"
    local st; st="$(git -C "$path" status --porcelain 2>/dev/null || true)"
    local state_icon="‚óè" state_color="$C_GREEN" state_text="clean"
    local dirty=false
    local mismatch=false

    if [[ -n "$st" ]]; then
      local changes; changes="$(print -r -- "$st" | wc -l | tr -d ' ')"
      state_icon="‚óê"
      state_color="$C_YELLOW"
      state_text="$changes uncommitted"
      dirty=true
    fi

    # Check for branch/directory mismatch
    local match_result="" expected_slug=""
    if [[ -n "$branch" ]]; then
      match_result="$(check_branch_directory_match "$path" "$branch" "$repo")"
      if [[ "$match_result" == mismatch\|* ]]; then
        mismatch=true
        expected_slug="${match_result#mismatch|}"
      fi
    fi

    # Get ahead/behind
    local counts; counts="$(get_ahead_behind "$path" "$DEFAULT_BASE")"
    local ahead="${counts%% *}" behind="${counts##* }"

    if [[ "$JSON_OUTPUT" == true ]]; then
      json_items+=("{\"path\": \"$(json_escape "$path")\", \"branch\": \"$(json_escape "$branch")\", \"sha\": \"$(json_escape "$sha")\", \"url\": \"$(json_escape "$url")\", \"dirty\": $dirty, \"ahead\": $ahead, \"behind\": $behind, \"mismatch\": $mismatch}")
    else
      print -r -- "${C_BOLD}[$idx]${C_RESET} üìÅ ${C_CYAN}$path${C_RESET}"
      if [[ -n "$branch" ]]; then
        print -r -- "    ${C_DIM}branch${C_RESET}  üåø ${C_MAGENTA}$branch${C_RESET}"
      else
        [[ -n "$head" ]] && print -r -- "    ${C_DIM}head${C_RESET}    ${C_YELLOW}${head:0:12}${C_RESET} (detached)"
      fi
      [[ -n "$sha" ]] && print -r -- "    ${C_DIM}sha${C_RESET}     ${C_DIM}$sha${C_RESET}"
      print -r -- "    ${C_DIM}state${C_RESET}   ${state_color}${state_icon} ${state_text}${C_RESET}"
      if (( ahead > 0 || behind > 0 )); then
        print -r -- "    ${C_DIM}sync${C_RESET}    ${C_GREEN}‚Üë$ahead${C_RESET} ${C_RED}‚Üì$behind${C_RESET}"
      fi
      print -r -- "    ${C_DIM}url${C_RESET}     üåê ${C_BLUE}$url${C_RESET}"
      print -r -- "    ${C_DIM}cd${C_RESET}      ${C_DIM}cd ${(q)path}${C_RESET}"
      if [[ "$mismatch" == true ]]; then
        print -r -- "    ${C_RED}‚ö† MISMATCH${C_RESET} Directory name doesn't match branch!"
        print -r -- "      ${C_DIM}Expected:${C_RESET} ${repo}--${expected_slug}"
      fi
      print -r -- ""
    fi
  }

  local path="" branch="" head="" idx=0 line=""
  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ -n "$path" ]]; then
        idx=$((idx + 1))
        display_worktree "$idx" "$path" "$branch" "$head"
      fi
      path=""; branch=""; head=""
      continue
    fi

    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
    [[ "$line" == HEAD\ * ]] && head="${line#HEAD }"
  done <<< "$out"

  # Handle last entry (no trailing blank line)
  if [[ -n "$path" ]]; then
    idx=$((idx + 1))
    display_worktree "$idx" "$path" "$branch" "$head"
  fi

  if [[ "$JSON_OUTPUT" == true ]]; then
    format_json "[${(j:, :)json_items}]"
  fi
}

cmd_status() {
  local repo="${1:-}"
  local stale_threshold=50
  local inactive_days=30

  [[ -n "$repo" ]] || die "Usage: wt status <repo>"

  validate_name "$repo" "repository"

  local git_dir
  git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  local out
  out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  # JSON output mode
  local json_items=()

  if [[ "$JSON_OUTPUT" != true ]]; then
    print -r -- ""
    print -r -- "${C_BOLD}üìä Worktree Status: ${C_CYAN}$repo${C_RESET}"
    print -r -- ""
    printf "  ${C_DIM}%-28s %-10s %-14s %-6s %-7s %-10s${C_RESET}\n" "BRANCH" "STATE" "SYNC" "AGE" "MERGED" "SHA"
    print -r -- "  ${C_DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${C_RESET}"
  fi

  local path="" branch="" head="" line=""
  local sha st state_icon state_color changes counts ahead behind
  local age age_days merged_icon sync_display is_stale is_inactive
  local mismatches=()

  # Helper to display a worktree row
  display_status_row() {
    local p="$1" b="$2"

    sha="$(git -C "$p" rev-parse --short HEAD 2>/dev/null)" || sha="?"
    st="$(git -C "$p" status --porcelain 2>/dev/null)" || st=""
    state_icon="‚óè"
    state_color="$C_GREEN"
    is_stale=false
    is_inactive=false

    if [[ -n "$st" ]]; then
      changes="$(print -r -- "$st" | wc -l | tr -d ' ')"
      state_icon="‚óê $changes"
      state_color="$C_YELLOW"
    fi

    # Check for mismatch
    local match_result="$(check_branch_directory_match "$p" "$b" "$repo")"
    if [[ "$match_result" == mismatch\|* ]]; then
      local expected_slug="${match_result#mismatch|}"
      mismatches+=("${p:t}|$b|$expected_slug")
    fi

    # Get sync status
    counts="$(get_ahead_behind "$p" "$DEFAULT_BASE")"
    ahead="${counts%% *}"
    behind="${counts##* }"

    # Check if stale (>50 commits behind)
    if (( behind > stale_threshold )); then
      is_stale=true
      sync_display="${C_RED}‚Üë$ahead ‚Üì$behind üî¥${C_RESET}"
    else
      sync_display="‚Üë$ahead ‚Üì$behind"
    fi

    # Get age
    age="$(get_last_commit_age "$p")"
    age_days="$(get_commit_age_days "$p")"
    if (( age_days > inactive_days )); then
      is_inactive=true
    fi

    # Check if merged
    if is_branch_merged "$p" "$DEFAULT_BASE"; then
      merged_icon="${C_DIM}‚úì${C_RESET}"
    else
      merged_icon="${C_DIM}-${C_RESET}"
    fi

    # Apply row colouring for stale/inactive
    local branch_display="${b:0:26}"
    local age_display="$age"
    if [[ "$is_stale" == true ]]; then
      branch_display="${C_RED}${b:0:26}${C_RESET}"
      state_color="$C_RED"
    elif [[ "$is_inactive" == true ]]; then
      age_display="${C_YELLOW}$age${C_RESET}"
    fi

    if [[ "$JSON_OUTPUT" == true ]]; then
      local dirty=false
      [[ -n "$st" ]] && dirty=true
      local merged=false
      is_branch_merged "$p" "$DEFAULT_BASE" && merged=true
      json_items+=("{\"branch\": \"$(json_escape "$b")\", \"path\": \"$(json_escape "$p")\", \"sha\": \"$(json_escape "$sha")\", \"dirty\": $dirty, \"changes\": ${changes:-0}, \"ahead\": $ahead, \"behind\": $behind, \"stale\": $is_stale, \"age\": \"$age\", \"age_days\": $age_days, \"merged\": $merged}")
    else
      printf "  %-28s ${state_color}%-10s${C_RESET} %-14s %-6s %-7s ${C_DIM}%-10s${C_RESET}\n" \
        "$branch_display" "$state_icon" "$sync_display" "$age_display" "$merged_icon" "$sha"
    fi
  }

  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      # Skip bare repo entry (no branch) and process worktrees
      if [[ -n "$path" && -n "$branch" && "$path" != "$git_dir" ]]; then
        display_status_row "$path" "$branch"
      fi
      path=""
      branch=""
      head=""
      continue
    fi

    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
    [[ "$line" == HEAD\ * ]] && head="${line#HEAD }"
  done <<< "$out"

  # Handle last entry
  if [[ -n "$path" && -n "$branch" && "$path" != "$git_dir" ]]; then
    display_status_row "$path" "$branch"
  fi

  # JSON output
  if [[ "$JSON_OUTPUT" == true ]]; then
    format_json "[${(j:, :)json_items}]"
    return 0
  fi

  # Show mismatch warnings
  if (( ${#mismatches[@]} > 0 )); then
    print -r -- ""
    print -r -- "${C_RED}${C_BOLD}‚ö† Branch/Directory Mismatches Detected:${C_RESET}"
    for m in "${mismatches[@]}"; do
      local dir="${m%%|*}"
      local rest="${m#*|}"
      local actual_branch="${rest%%|*}"
      local expected_slug="${rest#*|}"
      print -r -- "  ${C_YELLOW}$dir${C_RESET}"
      print -r -- "    ${C_DIM}Current branch:${C_RESET}  ${C_MAGENTA}$actual_branch${C_RESET}"
      print -r -- "    ${C_DIM}Expected dir:${C_RESET}    ${repo}--${expected_slug}"
      print -r -- "    ${C_DIM}Fix:${C_RESET} Checkout correct branch or recreate worktree"
    done
  fi

  print -r -- ""
}

cmd_pull() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to pull")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt pull [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"

  ensure_bare_repo "$git_dir"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  info "Pulling latest changes in ${C_MAGENTA}$branch${C_RESET}..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git -C "$wt_path" pull --rebase
  ok "Pull complete"

  # Run post-pull hooks
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  run_hooks "post-pull" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"
}

cmd_pull_all() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt pull-all <repo>"

  validate_name "$repo" "repository"

  local git_dir
  git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  local out
  out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  # Collect worktrees first, then process outside the loop
  local worktrees=()
  local path="" branch="" line=""

  while IFS= read -r line; do
    if [[ -z "$line" ]]; then
      if [[ -n "$path" && -n "$branch" && "$path" != "$git_dir" && -d "$path" ]]; then
        worktrees+=("$path|$branch")
      fi
      path=""
      branch=""
      continue
    fi
    [[ "$line" == worktree\ * ]] && path="${line#worktree }"
    [[ "$line" == branch\ refs/heads/* ]] && branch="${line#branch refs/heads/}"
  done <<< "$out"

  # Handle last entry
  if [[ -n "$path" && -n "$branch" && "$path" != "$git_dir" && -d "$path" ]]; then
    worktrees+=("$path|$branch")
  fi

  # Now pull each worktree in parallel
  local total=${#worktrees[@]}
  local count=0 failed=0
  export GIT_SSH_COMMAND="/usr/bin/ssh"

  info "Pulling $total worktree(s) in parallel..."

  # Create temp directory for results
  local tmpdir; tmpdir="$(/usr/bin/mktemp -d)"
  trap "/bin/rm -rf '$tmpdir'" EXIT

  # Launch parallel pulls
  local pids=()
  local idx=0
  for wt_entry in "${worktrees[@]}"; do
    local wt_path="${wt_entry%%|*}"
    local wt_branch="${wt_entry##*|}"

    (
      if /usr/bin/git -C "$wt_path" pull --rebase >/dev/null 2>&1; then
        print -r -- "ok" > "$tmpdir/$idx"
      else
        print -r -- "fail" > "$tmpdir/$idx"
      fi
    ) &
    pids+=($!)
    idx=$((idx + 1))
  done

  # Wait for all to complete
  for pid in "${pids[@]}"; do
    wait "$pid" 2>/dev/null || true
  done

  # Collect results
  idx=0
  for wt_entry in "${worktrees[@]}"; do
    local wt_branch="${wt_entry##*|}"
    if [[ -f "$tmpdir/$idx" && "$(/bin/cat "$tmpdir/$idx")" == "ok" ]]; then
      ok "  $wt_branch"
      count=$((count + 1))
    else
      warn "  $wt_branch - failed"
      failed=$((failed + 1))
    fi
    idx=$((idx + 1))
  done

  /bin/rm -rf "$tmpdir"
  trap - EXIT

  print -r -- ""
  ok "Pulled $count worktree(s)"
  (( failed > 0 )) && warn "$failed worktree(s) had issues"

  # Send notification
  if (( failed > 0 )); then
    notify "wt pull-all" "Completed: $count success, $failed failed"
  else
    notify "wt pull-all" "All $count worktrees updated"
  fi
}

cmd_sync() {
  local repo="${1:-}"; local branch="${2:-}"; local base="${3:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to sync")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt sync [<repo> [<branch>]] [base]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  # Load repo-specific config (may override DEFAULT_BASE)
  load_repo_config "$git_dir"

  # Use provided base or default
  [[ -z "$base" ]] && base="$DEFAULT_BASE"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  # Check for uncommitted changes
  if [[ -n "$(/usr/bin/git -C "$wt_path" status --porcelain 2>/dev/null)" ]]; then
    die "Worktree has uncommitted changes. Commit or stash them first."
  fi

  info "Rebasing ${C_MAGENTA}$branch${C_RESET} onto ${C_DIM}$base${C_RESET}..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git -C "$wt_path" rebase "$base"
  ok "Sync complete"

  # Run post-sync hooks
  local app_url; app_url="$(url_for "$repo" "$branch")"
  local db_name; db_name="$(db_name_for "$repo" "$branch")"
  run_hooks "post-sync" "$repo" "$branch" "$wt_path" "$app_url" "$db_name"
}

cmd_clone() {
  local url="${1:-}"; local repo="${2:-}"; local initial_branch="${3:-}"
  [[ -n "$url" ]] || die "Usage: wt clone <url> [repo-name] [branch]"

  # Extract repo name from URL if not provided
  if [[ -z "$repo" ]]; then
    repo="${url##*/}"
    repo="${repo%.git}"
  fi

  validate_name "$repo" "repository"
  [[ -z "$initial_branch" ]] || validate_name "$initial_branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"

  [[ ! -d "$git_dir" ]] || die "Bare repo already exists at $git_dir"

  info "Cloning ${C_CYAN}$url${C_RESET} as bare repo..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git clone --bare "$url" "$git_dir"

  # Configure fetch to get all branches
  /usr/bin/git --git-dir="$git_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

  info "Fetching all branches..."
  GIT_SSH_COMMAND="/usr/bin/ssh" /usr/bin/git --git-dir="$git_dir" fetch --all --prune

  print -r -- ""
  ok "Bare repo created at ${C_CYAN}$git_dir${C_RESET}"

  # If specific branch requested, create worktree for it
  if [[ -n "$initial_branch" ]]; then
    print -r -- ""
    # Check if it's a remote branch
    if /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/$initial_branch"; then
      info "Creating worktree for ${C_GREEN}$initial_branch${C_RESET}..."
      cmd_add "$repo" "$initial_branch" "origin/$initial_branch"
    else
      # Branch doesn't exist on remote - create as new branch from default base
      local base_branch=""
      if /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/staging"; then
        base_branch="origin/staging"
      elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/main"; then
        base_branch="origin/main"
      elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/master"; then
        base_branch="origin/master"
      else
        die "Branch '$initial_branch' not found on remote and no default base branch available"
      fi
      info "Creating new branch ${C_GREEN}$initial_branch${C_RESET} from $base_branch..."
      cmd_add "$repo" "$initial_branch" "$base_branch"
    fi
  # Auto-create staging worktree if staging branch exists
  elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/staging"; then
    print -r -- ""
    info "Found staging branch - creating worktree..."
    cmd_add "$repo" "staging" "origin/staging"
  elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/main"; then
    print -r -- ""
    info "Found main branch - creating worktree..."
    cmd_add "$repo" "main" "origin/main"
  elif /usr/bin/git --git-dir="$git_dir" show-ref --quiet "refs/remotes/origin/master"; then
    print -r -- ""
    info "Found master branch - creating worktree..."
    cmd_add "$repo" "master" "origin/master"
  else
    dim "  Create a worktree with: wt add $repo <branch>"
    print -r -- ""
  fi

  notify "wt clone" "Repository $repo cloned successfully"
}

cmd_code() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to open")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt code [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  local editor="$DEFAULT_EDITOR"

  # Detect available editor
  if ! command -v "$editor" >/dev/null 2>&1; then
    if command -v cursor >/dev/null 2>&1; then
      editor="cursor"
    elif command -v code >/dev/null 2>&1; then
      editor="code"
    else
      die "No editor found. Install VS Code or Cursor, or set WT_EDITOR"
    fi
  fi

  info "Opening in ${C_BOLD}$editor${C_RESET}..."
  "$editor" "$wt_path"
}

cmd_prune() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt prune <repo>"

  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  info "Pruning stale worktrees..."
  git --git-dir="$git_dir" worktree prune -v

  info "Looking for merged branches..."

  # Get list of branches that have been merged to staging/main
  local merged; merged="$(git --git-dir="$git_dir" branch --merged origin/staging 2>/dev/null | grep -v 'staging\|main\|master' | tr -d ' ')" || merged=""

  if [[ -n "$merged" ]]; then
    print -r -- ""
    warn "The following branches appear to be merged:"
    print -r -- "$merged" | while read -r b; do
      [[ -n "$b" ]] && print -r -- "  ${C_DIM}$b${C_RESET}"
    done
    print -r -- ""

    if [[ "$FORCE" == true ]]; then
      print -r -- "$merged" | while read -r b; do
        [[ -n "$b" ]] && git --git-dir="$git_dir" branch -D "$b" 2>/dev/null && ok "Deleted $b"
      done
    else
      dim "Run with -f to delete merged branches"
    fi
  else
    ok "No merged branches to clean up"
  fi

  ok "Prune complete"
}

cmd_exec() {
  local repo="${1:-}"; local branch="${2:-}"
  shift 2 2>/dev/null || die "Usage: wt exec <repo> <branch> <command...>"
  local cmd=("$@")

  [[ -n "$repo" && -n "$branch" && ${#cmd[@]} -gt 0 ]] || die "Usage: wt exec <repo> <branch> <command...>"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path
  wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die "Worktree not found at $wt_path"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"
  "${cmd[@]}"
  popd >/dev/null
}

cmd_open() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to open")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt open [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  # Get actual worktree path
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  # Read APP_URL from .env file, fall back to folder-based URL
  local url=""
  if [[ -f "$wt_path/.env" ]]; then
    # Extract APP_URL, strip quotes and trailing comments
    url="$(grep -E '^APP_URL=' "$wt_path/.env" 2>/dev/null | head -1 | cut -d'=' -f2- | sed 's/#.*//' | tr -d '"' | tr -d "'" | tr -d ' ')"
  fi

  # Fallback to folder-based URL if APP_URL not found
  if [[ -z "$url" ]]; then
    local folder="${wt_path:t}"
    url="https://${folder}.test"
    dim "  No APP_URL in .env, using: $url"
  fi

  command -v open >/dev/null 2>&1 || die "'open' command not found (macOS expected)"
  open "$url"
}

cmd_cd() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt cd [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  resolve_wt_path "$repo" "$branch"
}

cmd_repos() {
  local repos; repos="$(list_repos)"

  if [[ -z "$repos" ]]; then
    dim "No repositories found in $HERD_ROOT"
    return 0
  fi

  if [[ "$JSON_OUTPUT" == true ]]; then
    local json_items=()
    while IFS= read -r repo; do
      local git_dir; git_dir="$(git_dir_for "$repo")"
      local wt_count; wt_count="$(git --git-dir="$git_dir" worktree list 2>/dev/null | wc -l | tr -d ' ')"
      wt_count=$((wt_count - 1))  # Subtract bare repo entry
      json_items+=("{\"name\": \"$(json_escape "$repo")\", \"worktrees\": $wt_count}")
    done <<< "$repos"
    format_json "[${(j:, :)json_items}]"
  else
    print -r -- ""
    print -r -- "${C_BOLD}üì¶ Repositories in ${C_CYAN}$HERD_ROOT${C_RESET}"
    print -r -- ""
    while IFS= read -r repo; do
      local git_dir; git_dir="$(git_dir_for "$repo")"
      local wt_count; wt_count="$(git --git-dir="$git_dir" worktree list 2>/dev/null | wc -l | tr -d ' ')"
      wt_count=$((wt_count - 1))  # Subtract bare repo entry
      print -r -- "  ${C_GREEN}$repo${C_RESET} ${C_DIM}($wt_count worktrees)${C_RESET}"
    done <<< "$repos"
    print -r -- ""
  fi
}

cmd_templates() {
  local template_name="${1:-}"

  if [[ -z "$template_name" ]]; then
    # List all templates
    print -r -- ""
    print -r -- "${C_BOLD}üìã Available Templates${C_RESET}"
    print -r -- ""
    list_templates
    print -r -- ""
    print -r -- "${C_DIM}Usage: wt templates <name>  - Show template details${C_RESET}"
    print -r -- "${C_DIM}       wt add <repo> <branch> --template=<name>${C_RESET}"
    print -r -- ""
    return 0
  fi

  # Show specific template details
  local template_file="$WT_TEMPLATES_DIR/${template_name}.conf"

  if [[ ! -f "$template_file" ]]; then
    die "Template not found: $template_name
       Expected: $template_file"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}üìã Template: ${C_CYAN}$template_name${C_RESET}"
  print -r -- ""

  # Extract description
  local desc; desc="$(grep '^TEMPLATE_DESC=' "$template_file" 2>/dev/null | head -1 | cut -d= -f2- | tr -d '"'"'")"
  if [[ -n "$desc" ]]; then
    print -r -- "${C_DIM}Description:${C_RESET} $desc"
    print -r -- ""
  fi

  print -r -- "${C_DIM}File:${C_RESET} $template_file"
  print -r -- ""
  print -r -- "${C_BOLD}Settings:${C_RESET}"

  # Show all WT_SKIP_* settings
  while IFS='=' read -r key value || [[ -n "$key" ]]; do
    [[ "$key" =~ ^[[:space:]]*# ]] && continue
    [[ -z "$key" || "$key" =~ ^[[:space:]]*$ ]] && continue

    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"

    case "$key" in
      WT_SKIP_*)
        value="${value#\"}"
        value="${value%\"}"
        value="${value%%#*}"
        value="${value%"${value##*[![:space:]]}"}"
        if [[ "$value" == "true" ]]; then
          print -r -- "  ${C_YELLOW}$key${C_RESET} = ${C_RED}true${C_RESET} (skipped)"
        else
          print -r -- "  ${C_GREEN}$key${C_RESET} = ${C_GREEN}false${C_RESET} (enabled)"
        fi
        ;;
    esac
  done < "$template_file"

  print -r -- ""
  print -r -- "${C_DIM}Usage: wt add <repo> <branch> --template=$template_name${C_RESET}"
  print -r -- ""
}

cmd_doctor() {
  print -r -- ""
  print -r -- "${C_BOLD}ü©∫ wt doctor${C_RESET}"
  print -r -- ""

  local issues=0

  # Check HERD_ROOT
  print -r -- "${C_BOLD}Configuration${C_RESET}"
  if [[ -d "$HERD_ROOT" ]]; then
    ok "HERD_ROOT: $HERD_ROOT"
  else
    warn "HERD_ROOT does not exist: $HERD_ROOT"
    issues=$((issues + 1))
  fi

  if [[ -d "$DB_BACKUP_DIR" ]]; then
    ok "DB_BACKUP_DIR: $DB_BACKUP_DIR"
  else
    dim "  DB_BACKUP_DIR does not exist (will be created on first backup): $DB_BACKUP_DIR"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Required Tools${C_RESET}"

  # Check git
  if command -v git >/dev/null 2>&1; then
    local git_version; git_version="$(git --version 2>/dev/null | head -1)"
    ok "git: $git_version"
  else
    warn "git: not found"
    issues=$((issues + 1))
  fi

  # Check composer
  if command -v composer >/dev/null 2>&1; then
    local composer_version; composer_version="$(composer --version 2>/dev/null | head -1)"
    ok "composer: $composer_version"
  else
    warn "composer: not found"
    issues=$((issues + 1))
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Optional Tools${C_RESET}"

  # Check mysql
  if command -v mysql >/dev/null 2>&1; then
    local mysql_version; mysql_version="$(mysql --version 2>/dev/null | head -1)"
    ok "mysql: $mysql_version"

    # Test connection
    local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER")
    if [[ -n "$DB_PASSWORD" ]]; then
      mysql_cmd+=(-p"$DB_PASSWORD")
    fi
    if "${mysql_cmd[@]}" -e "SELECT 1" >/dev/null 2>&1; then
      ok "  MySQL connection: OK"
    else
      warn "  MySQL connection: FAILED (check DB_HOST, DB_USER, DB_PASSWORD)"
    fi
  else
    dim "  mysql: not found (database features disabled)"
  fi

  # Check herd
  if command -v herd >/dev/null 2>&1; then
    ok "herd: installed"
  else
    dim "  herd: not found (site securing disabled)"
  fi

  # Check fzf
  if command -v fzf >/dev/null 2>&1; then
    ok "fzf: installed"
  else
    dim "  fzf: not found (interactive selection disabled)"
  fi

  # Check editor
  if command -v "$DEFAULT_EDITOR" >/dev/null 2>&1; then
    ok "editor: $DEFAULT_EDITOR"
  else
    dim "  editor: $DEFAULT_EDITOR not found"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Config Files${C_RESET}"

  local config_file="${WT_CONFIG:-$HOME/.wtrc}"
  if [[ -f "$config_file" ]]; then
    ok "User config: $config_file"
  else
    dim "  User config: $config_file (not found)"
  fi

  if [[ -f "$HERD_ROOT/.wtconfig" ]]; then
    ok "Project config: $HERD_ROOT/.wtconfig"
  else
    dim "  Project config: $HERD_ROOT/.wtconfig (not found)"
  fi

  print -r -- ""
  print -r -- "${C_BOLD}Hooks${C_RESET}"

  if [[ -d "$WT_HOOKS_DIR" ]]; then
    ok "Hooks directory: $WT_HOOKS_DIR"

    # Check for post-add hook
    if [[ -x "$WT_HOOKS_DIR/post-add" ]]; then
      ok "  post-add: enabled"
    elif [[ -f "$WT_HOOKS_DIR/post-add" ]]; then
      warn "  post-add: exists but not executable"
    else
      dim "  post-add: not configured"
    fi

    # Check for post-add.d directory
    if [[ -d "$WT_HOOKS_DIR/post-add.d" ]]; then
      local hook_count; hook_count="$(ls -1 "$WT_HOOKS_DIR/post-add.d" 2>/dev/null | wc -l | tr -d ' ')" || hook_count=0
      if (( hook_count > 0 )); then
        ok "  post-add.d/: $hook_count script(s)"
      fi
    fi

    # Check for post-rm hook
    if [[ -x "$WT_HOOKS_DIR/post-rm" ]]; then
      ok "  post-rm: enabled"
    elif [[ -f "$WT_HOOKS_DIR/post-rm" ]]; then
      warn "  post-rm: exists but not executable"
    else
      dim "  post-rm: not configured"
    fi

    # Check for post-rm.d directory
    if [[ -d "$WT_HOOKS_DIR/post-rm.d" ]]; then
      local hook_count; hook_count="$(ls -1 "$WT_HOOKS_DIR/post-rm.d" 2>/dev/null | wc -l | tr -d ' ')" || hook_count=0
      if (( hook_count > 0 )); then
        ok "  post-rm.d/: $hook_count script(s)"
      fi
    fi
  else
    dim "  Hooks directory: $WT_HOOKS_DIR (not found)"
    dim "  üí° Create hooks with: mkdir -p $WT_HOOKS_DIR"
  fi

  print -r -- ""
  if (( issues > 0 )); then
    warn "$issues issue(s) found"
  else
    ok "All checks passed!"
  fi
  print -r -- ""
}

# Clean up orphaned Herd nginx configs and certificates
# Finds configs for sites that no longer have corresponding worktrees
cmd_cleanup_herd() {
  print -r -- ""
  print -r -- "${C_BOLD}üßπ Cleaning orphaned Herd configs${C_RESET}"
  print -r -- ""

  if ! command -v herd >/dev/null 2>&1; then
    die "Herd is not installed"
  fi

  local nginx_dir="$HERD_CONFIG/valet/Nginx"
  local cert_dir="$HERD_CONFIG/valet/Certificates"
  local orphaned=()
  local cleaned=0

  if [[ ! -d "$nginx_dir" ]]; then
    warn "Nginx config directory not found: $nginx_dir"
    return 1
  fi

  info "Scanning for orphaned configs..."

  # Find all nginx configs that look like worktree sites (contain --)
  for config in "$nginx_dir"/*--*.test(N); do
    [[ -f "$config" ]] || continue
    local site_name="${config:t}"  # e.g., scooda--feature-xyz.test
    local folder_name="${site_name%.test}"  # e.g., scooda--feature-xyz
    local wt_path="$HERD_ROOT/$folder_name"

    # Check if the worktree directory exists
    if [[ ! -d "$wt_path" ]]; then
      orphaned+=("$site_name")
    fi
  done

  if (( ${#orphaned[@]} == 0 )); then
    ok "No orphaned configs found"
    print -r -- ""
    return 0
  fi

  print -r -- ""
  warn "Found ${C_BOLD}${#orphaned[@]}${C_RESET}${C_YELLOW} orphaned config(s):${C_RESET}"
  for site in "${orphaned[@]}"; do
    print -r -- "  ${C_DIM}‚Ä¢${C_RESET} $site"
  done
  print -r -- ""

  if [[ "$FORCE" == false ]]; then
    print -n "${C_YELLOW}Remove these orphaned configs? [y/N]${C_RESET} "
    local response
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || { dim "Aborted"; return 0; }
  fi

  print -r -- ""
  for site_name in "${orphaned[@]}"; do
    local folder_name="${site_name%.test}"
    info "Cleaning ${C_CYAN}$site_name${C_RESET}"

    # Remove nginx config
    local nginx_config="$nginx_dir/$site_name"
    if [[ -f "$nginx_config" ]]; then
      /bin/rm -f "$nginx_config" 2>/dev/null
    fi

    # Remove certificate files
    for ext in crt key csr conf; do
      local cert_file="$cert_dir/${site_name}.${ext}"
      if [[ -f "$cert_file" ]]; then
        /bin/rm -f "$cert_file" 2>/dev/null
      fi
    done

    cleaned=$((cleaned + 1))
  done

  # Restart nginx to apply changes
  info "Restarting Herd nginx..."
  herd restart >/dev/null 2>&1

  print -r -- ""
  ok "Cleaned ${C_BOLD}$cleaned${C_RESET} orphaned config(s)"
  print -r -- ""
}

cmd_unlock() {
  local repo="${1:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    dim "  Detected: $repo"
  fi

  if [[ -n "$repo" ]]; then
    # Unlock specific repo
    validate_name "$repo" "repository"
    local git_dir; git_dir="$(git_dir_for "$repo")"
    ensure_bare_repo "$git_dir"

    local worktrees_dir="$git_dir/worktrees"
    if [[ ! -d "$worktrees_dir" ]]; then
      dim "No worktrees directory found for $repo"
      return 0
    fi

    local count=0
    for lock_file in "$worktrees_dir"/*/index.lock(N); do
      if [[ -f "$lock_file" ]]; then
        local wt_name="${${lock_file:h}:t}"
        rm -f "$lock_file"
        ok "Removed lock: ${C_CYAN}$wt_name${C_RESET}"
        count=$((count + 1))
      fi
    done

    if (( count == 0 )); then
      ok "No stale lock files found for ${C_CYAN}$repo${C_RESET}"
    else
      ok "Removed ${C_BOLD}$count${C_RESET} lock file(s)"
    fi
  else
    # Unlock all repos
    info "Scanning all repositories..."
    local total=0

    for git_dir in "$HERD_ROOT"/*.git(N); do
      [[ -d "$git_dir" ]] || continue
      local repo_name="${${git_dir:t}%.git}"
      local worktrees_dir="$git_dir/worktrees"

      [[ -d "$worktrees_dir" ]] || continue

      for lock_file in "$worktrees_dir"/*/index.lock(N); do
        if [[ -f "$lock_file" ]]; then
          local wt_name="${${lock_file:h}:t}"
          rm -f "$lock_file"
          ok "Removed lock: ${C_CYAN}$repo_name${C_RESET} / ${C_MAGENTA}$wt_name${C_RESET}"
          total=$((total + 1))
        fi
      done
    done

    if (( total == 0 )); then
      ok "No stale lock files found"
    else
      ok "Removed ${C_BOLD}$total${C_RESET} lock file(s)"
    fi
  fi
}

cmd_fresh() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
    dim "  Detected: $repo / $branch"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to refresh")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt fresh [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"

  print -r -- ""
  print -r -- "${C_BOLD}üîÑ Refreshing ${C_CYAN}$repo${C_RESET} / ${C_MAGENTA}$branch${C_RESET}"
  print -r -- ""

  # Run migrate:fresh --seed (with confirmation unless forced)
  if [[ -f "artisan" ]]; then
    if [[ "$FORCE" == false ]]; then
      warn "This will DROP ALL TABLES in the database!"
      print -n "${C_YELLOW}Continue with migrate:fresh? [y/N]${C_RESET} "
      local response
      read -r response
      if [[ ! "$response" =~ ^[Yy]$ ]]; then
        warn "Skipping migrate:fresh"
        popd >/dev/null
        return 0
      fi
    fi

    info "Running migrate:fresh --seed..."
    if php artisan migrate:fresh --seed; then
      ok "Database refreshed"
    else
      warn "migrate:fresh --seed failed"
    fi
  fi

  # Run npm ci
  if [[ -f "package.json" ]]; then
    info "Running npm ci..."
    if npm ci; then
      ok "npm dependencies installed"
    else
      warn "npm ci failed"
    fi

    # Run npm run build
    info "Running npm run build..."
    if npm run build; then
      ok "Assets built"
    else
      warn "npm run build failed"
    fi
  fi

  popd >/dev/null

  notify "wt fresh" "Completed for $repo / $branch"
  print -r -- ""
  ok "Fresh complete!"
  print -r -- ""
}

cmd_switch() {
  local repo="${1:-}"; local branch="${2:-}"

  # Note: No auto-detect for switch - it's meant to switch TO a different worktree

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to switch to")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt switch <repo> [<branch>]"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  # Read APP_URL from .env file, fall back to folder-based URL
  local url=""
  if [[ -f "$wt_path/.env" ]]; then
    # Extract APP_URL, strip quotes and trailing comments
    url="$(grep -E '^APP_URL=' "$wt_path/.env" 2>/dev/null | head -1 | cut -d'=' -f2- | sed 's/#.*//' | tr -d '"' | tr -d "'" | tr -d ' ')"
  fi
  if [[ -z "$url" ]]; then
    local folder="${wt_path:t}"
    url="https://${folder}.test"
  fi

  # Print path for cd (user can use: cd "$(wt switch ...)")
  print -r -- "$wt_path"

  # Open in editor
  local editor="$DEFAULT_EDITOR"
  if command -v "$editor" >/dev/null 2>&1; then
    "$editor" "$wt_path" &
  fi

  # Open in browser
  if command -v open >/dev/null 2>&1; then
    open "$url" &
  fi
}

cmd_migrate() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt migrate [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"
  [[ -f "$wt_path/artisan" ]] || die "Not a Laravel project (no artisan file)"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"
  php artisan migrate
  popd >/dev/null
}

cmd_tinker() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt tinker [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"
  [[ -f "$wt_path/artisan" ]] || die "Not a Laravel project (no artisan file)"

  pushd "$wt_path" >/dev/null || die "Failed to cd into $wt_path"
  php artisan tinker
  popd >/dev/null
}

cmd_log() {
  local repo="${1:-}"; local branch="${2:-}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt log [<repo> [<branch>]]
       Run from within a worktree to auto-detect, or specify repo/branch."

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  print -r -- ""
  print -r -- "${C_BOLD}üìú Recent commits in ${C_MAGENTA}$branch${C_RESET} ${C_DIM}(vs $DEFAULT_BASE)${C_RESET}"
  print -r -- ""

  git -C "$wt_path" log --oneline --graph -n 20 "$DEFAULT_BASE"..HEAD 2>/dev/null || \
    git -C "$wt_path" log --oneline --graph -n 20

  print -r -- ""
}

cmd_diff() {
  local repo="${1:-}"; local branch="${2:-}"; local base="${3:-$DEFAULT_BASE}"

  # Auto-detect from current directory if no args
  if [[ -z "$repo" ]] && detect_current_worktree; then
    repo="$DETECTED_REPO"
    branch="$DETECTED_BRANCH"
  fi

  # Handle fzf selection if branch not provided
  if [[ -n "$repo" && -z "$branch" ]] && command -v fzf >/dev/null 2>&1; then
    validate_name "$repo" "repository"
    branch="$(select_branch_fzf "$repo" "Select worktree to diff")" || die "No branch selected"
  fi

  [[ -n "$repo" && -n "$branch" ]] || die "Usage: wt diff [<repo> [<branch>]] [base]
       Run from within a worktree to auto-detect, or specify repo/branch.
       Default base: $DEFAULT_BASE"

  validate_name "$repo" "repository"
  validate_name "$branch" "branch"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  local wt_path; wt_path="$(resolve_wt_path "$repo" "$branch")"

  ensure_bare_repo "$git_dir"
  [[ -d "$wt_path" ]] || die_wt_not_found "$repo" "$wt_path"

  # Fetch to ensure we have latest base
  info "Fetching latest..."
  git --git-dir="$git_dir" fetch --all --prune --quiet

  # Check if base exists
  if ! git -C "$wt_path" rev-parse --verify "$base" >/dev/null 2>&1; then
    die "Base branch '$base' not found. Try: origin/main, origin/staging, or origin/master"
  fi

  # Get stats
  local commits; commits="$(git -C "$wt_path" rev-list --count "$base"..HEAD 2>/dev/null)" || commits="?"
  local files; files="$(git -C "$wt_path" diff --stat "$base"..HEAD 2>/dev/null | tail -1)" || files=""

  print -r -- ""
  print -r -- "${C_BOLD}üìä Diff: ${C_MAGENTA}$branch${C_RESET} ${C_DIM}vs${C_RESET} ${C_CYAN}$base${C_RESET}"
  print -r -- ""
  print -r -- "  ${C_DIM}Commits:${C_RESET} $commits"
  [[ -n "$files" ]] && print -r -- "  ${C_DIM}Summary:${C_RESET} $files"
  print -r -- ""

  # Show the diff
  git -C "$wt_path" diff "$base"..HEAD --stat

  print -r -- ""
  dim "  üí° For full diff: git -C \"$wt_path\" diff $base..HEAD"
  dim "  üí° For patch:     git -C \"$wt_path\" diff $base..HEAD > changes.patch"
  print -r -- ""
}

cmd_report() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt report <repo> [--output <file>]"
  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  local output_file=""
  if [[ "${2:-}" == "--output" && -n "${3:-}" ]]; then
    output_file="$3"
  fi

  # Generate markdown report
  local report=""
  report+="# Worktree Report: $repo\n\n"
  report+="Generated: $(date '+%Y-%m-%d %H:%M:%S')\n\n"

  # Get worktree list
  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || true
  [[ -n "$out" ]] || { dim "No worktrees found."; return 0; }

  report+="## Summary\n\n"

  local total=0 clean=0 dirty=0
  local path="" branch="" head=""

  # First pass - count stats
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == worktree\ * ]]; then
      path="${line#worktree }"
    elif [[ "$line" == "branch refs/heads/"* ]]; then
      branch="${line#branch refs/heads/}"
    elif [[ "$line" == HEAD\ * ]]; then
      head="${line#HEAD }"
    elif [[ -z "$line" && -n "$path" ]]; then
      [[ "$path" == *.git ]] && { path=""; branch=""; head=""; continue; }
      total=$((total + 1))
      local status; status="$(git -C "$path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
      if (( status > 0 )); then
        dirty=$((dirty + 1))
      else
        clean=$((clean + 1))
      fi
      path=""; branch=""; head=""
    fi
  done <<< "$out"

  report+="| Metric | Count |\n"
  report+="|--------|-------|\n"
  report+="| Total worktrees | $total |\n"
  report+="| Clean | $clean |\n"
  report+="| With changes | $dirty |\n\n"

  report+="## Worktrees\n\n"
  report+="| Branch | Status | Ahead | Behind | Last Commit |\n"
  report+="|--------|--------|-------|--------|-------------|\n"

  # Second pass - generate table
  path=""; branch=""; head=""
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == worktree\ * ]]; then
      path="${line#worktree }"
    elif [[ "$line" == "branch refs/heads/"* ]]; then
      branch="${line#branch refs/heads/}"
    elif [[ "$line" == HEAD\ * ]]; then
      head="${line#HEAD }"
    elif [[ -z "$line" && -n "$path" ]]; then
      [[ "$path" == *.git ]] && { path=""; branch=""; head=""; continue; }

      local status_count; status_count="$(git -C "$path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')"
      local status_icon="‚úÖ"
      (( status_count > 0 )) && status_icon="‚ö†Ô∏è $status_count changes"

      local ahead=0 behind=0
      local upstream; upstream="$(git -C "$path" rev-parse --abbrev-ref '@{upstream}' 2>/dev/null)" || upstream=""
      if [[ -n "$upstream" ]]; then
        ahead="$(git -C "$path" rev-list --count '@{upstream}'..HEAD 2>/dev/null)" || ahead=0
        behind="$(git -C "$path" rev-list --count HEAD..'@{upstream}' 2>/dev/null)" || behind=0
      fi

      local last_commit; last_commit="$(git -C "$path" log -1 --format='%s' 2>/dev/null | cut -c1-40)" || last_commit=""
      [[ ${#last_commit} -ge 40 ]] && last_commit="${last_commit}..."

      report+="| \`$branch\` | $status_icon | $ahead | $behind | $last_commit |\n"

      path=""; branch=""; head=""
    fi
  done <<< "$out"

  report+="\n## Hooks Available\n\n"
  if [[ -d "$WT_HOOKS_DIR" ]]; then
    for hook_type in pre-add post-add pre-rm post-rm post-pull post-sync; do
      if [[ -x "$WT_HOOKS_DIR/$hook_type" ]] || [[ -d "$WT_HOOKS_DIR/${hook_type}.d" ]]; then
        report+="- ‚úÖ \`$hook_type\`\n"
      else
        report+="- ‚¨ú \`$hook_type\`\n"
      fi
    done
  else
    report+="No hooks directory found at \`$WT_HOOKS_DIR\`\n"
  fi

  # Output report
  if [[ -n "$output_file" ]]; then
    print -r -- "$report" > "$output_file"
    ok "Report saved to: $output_file"
  else
    print -r -- "$report"
  fi
}

cmd_health() {
  local repo="${1:-}"
  [[ -n "$repo" ]] || die "Usage: wt health <repo>"
  validate_name "$repo" "repository"

  local git_dir; git_dir="$(git_dir_for "$repo")"
  ensure_bare_repo "$git_dir"

  print -r -- ""
  print -r -- "${C_BOLD}üè• Health Check: ${C_CYAN}$repo${C_RESET}"
  print -r -- ""

  local issues=0 warnings=0

  # Check for stale worktrees (directories that no longer exist)
  print -r -- "${C_BOLD}Stale Worktrees${C_RESET}"
  local stale; stale="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null | grep -A1 '^worktree ' | grep -v '^worktree ' | grep -v '^--$' | while read -r path; do
    [[ -n "$path" && ! -d "$path" ]] && echo "$path"
  done)"
  if [[ -n "$stale" ]]; then
    warn "Found stale worktree references:"
    print -r -- "$stale" | while read -r path; do
      print -r -- "  ${C_RED}‚úñ${C_RESET} $path"
    done
    issues=$((issues + 1))
    dim "  üí° Fix: wt prune $repo"
  else
    ok "No stale worktrees"
  fi
  print -r -- ""

  # Check for orphaned databases
  print -r -- "${C_BOLD}Database Health${C_RESET}"
  if command -v mysql >/dev/null 2>&1; then
    local mysql_cmd=(mysql -h "$DB_HOST" -u "$DB_USER" -N -B)
    [[ -n "$DB_PASSWORD" ]] && mysql_cmd+=(-p"$DB_PASSWORD")

    # Get all databases matching repo pattern
    local dbs; dbs="$("${mysql_cmd[@]}" -e "SHOW DATABASES LIKE '${repo}__%'" 2>/dev/null)" || dbs=""

    if [[ -n "$dbs" ]]; then
      local orphaned=0
      while read -r db; do
        # Check if corresponding worktree exists
        local found=false
        local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || out=""
        while IFS= read -r line; do
          if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            local wt_db; wt_db="$(db_name_for "$repo" "${wt_path##*--}")"
            [[ "$wt_db" == "$db" ]] && found=true && break
          fi
        done <<< "$out"

        if [[ "$found" == false ]]; then
          [[ $orphaned -eq 0 ]] && warn "Potentially orphaned databases:"
          print -r -- "  ${C_YELLOW}?${C_RESET} $db"
          orphaned=$((orphaned + 1))
        fi
      done <<< "$dbs"

      if [[ $orphaned -eq 0 ]]; then
        ok "No orphaned databases found"
      else
        warnings=$((warnings + orphaned))
        dim "  üí° Verify and drop if not needed: mysql -e 'DROP DATABASE <name>'"
      fi
    else
      dim "  No databases found matching pattern ${repo}__*"
    fi
  else
    dim "  MySQL not available - skipping database checks"
  fi
  print -r -- ""

  # Check for missing .env files
  print -r -- "${C_BOLD}Environment Files${C_RESET}"
  local out; out="$(git --git-dir="$git_dir" worktree list --porcelain 2>/dev/null)" || out=""
  local missing_env=0
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      local path="${line#worktree }"
      [[ "$path" == *.git ]] && continue
      if [[ -f "$path/.env.example" && ! -f "$path/.env" ]]; then
        [[ $missing_env -eq 0 ]] && warn "Worktrees missing .env file:"
        print -r -- "  ${C_YELLOW}!${C_RESET} ${path##*/}"
        missing_env=$((missing_env + 1))
      fi
    fi
  done <<< "$out"
  if [[ $missing_env -eq 0 ]]; then
    ok "All worktrees have .env files"
  else
    warnings=$((warnings + missing_env))
    dim "  üí° Fix: cd <worktree> && cp .env.example .env"
  fi
  print -r -- ""

  # Check for branch/directory mismatches
  print -r -- "${C_BOLD}Branch Consistency${C_RESET}"
  local mismatches=0
  check_worktree_mismatches "$git_dir"
  mismatches=$?
  if [[ $mismatches -eq 0 ]]; then
    ok "All worktrees match their expected branches"
  else
    issues=$((issues + mismatches))
  fi
  print -r -- ""

  # Summary
  print -r -- "${C_BOLD}Summary${C_RESET}"
  if [[ $issues -eq 0 && $warnings -eq 0 ]]; then
    ok "No issues found - repository is healthy! üéâ"
  else
    [[ $issues -gt 0 ]] && warn "$issues issue(s) need attention"
    [[ $warnings -gt 0 ]] && dim "  $warnings warning(s) to review"
  fi
  print -r -- ""
}

usage() {
  print -r -- ""
  print -r -- "${C_BOLD}üå≥ wt${C_RESET} v$VERSION - Git worktree manager for Laravel Herd"
  print -r -- ""
  print -r -- "${C_BOLD}USAGE${C_RESET}"
  print -r -- "  wt [flags] <command> [args]"
  print -r -- ""
  print -r -- "${C_BOLD}CORE COMMANDS${C_RESET}"
  print -r -- "  ${C_GREEN}add${C_RESET}      ${C_DIM}<repo> <branch> [base]${C_RESET}     Create worktree"
  print -r -- "           ${C_DIM}--template=<name>, -t <name>${C_RESET}  Use template"
  print -r -- "           ${C_DIM}--dry-run${C_RESET}                     Preview without creating"
  print -r -- "  ${C_GREEN}rm${C_RESET}       ${C_DIM}<repo> [branch]${C_RESET}            Remove worktree"
  print -r -- "  ${C_GREEN}ls${C_RESET}       ${C_DIM}<repo>${C_RESET}                     List worktrees"
  print -r -- "  ${C_GREEN}repos${C_RESET}                               List all repositories"
  print -r -- "  ${C_GREEN}clone${C_RESET}    ${C_DIM}<url> [name] [branch]${C_RESET}      Clone as bare repo"
  print -r -- ""
  print -r -- "${C_BOLD}GIT COMMANDS${C_RESET} ${C_DIM}(auto-detect repo/branch when run from worktree)${C_RESET}"
  print -r -- "  ${C_GREEN}status${C_RESET}   ${C_DIM}<repo>${C_RESET}                     Dashboard view of all worktrees"
  print -r -- "  ${C_GREEN}pull${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Pull latest changes"
  print -r -- "  ${C_GREEN}pull-all${C_RESET} ${C_DIM}<repo>${C_RESET}                     Pull all worktrees (parallel)"
  print -r -- "  ${C_GREEN}sync${C_RESET}     ${C_DIM}[repo] [branch] [base]${C_RESET}     Rebase onto base branch"
  print -r -- "  ${C_GREEN}diff${C_RESET}     ${C_DIM}[repo] [branch] [base]${C_RESET}     Show diff against base branch"
  print -r -- "  ${C_GREEN}log${C_RESET}      ${C_DIM}[repo] [branch]${C_RESET}            Show recent commits"
  print -r -- "  ${C_GREEN}prune${C_RESET}    ${C_DIM}<repo>${C_RESET}                     Clean up stale worktrees"
  print -r -- ""
  print -r -- "${C_BOLD}LARAVEL COMMANDS${C_RESET} ${C_DIM}(auto-detect when run from worktree)${C_RESET}"
  print -r -- "  ${C_GREEN}fresh${C_RESET}    ${C_DIM}[repo] [branch]${C_RESET}            migrate:fresh + npm ci + build"
  print -r -- "  ${C_GREEN}migrate${C_RESET}  ${C_DIM}[repo] [branch]${C_RESET}            Run artisan migrate"
  print -r -- "  ${C_GREEN}tinker${C_RESET}   ${C_DIM}[repo] [branch]${C_RESET}            Run artisan tinker"
  print -r -- ""
  print -r -- "${C_BOLD}NAVIGATION${C_RESET} ${C_DIM}(auto-detect when run from worktree)${C_RESET}"
  print -r -- "  ${C_GREEN}code${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Open in editor"
  print -r -- "  ${C_GREEN}open${C_RESET}     ${C_DIM}[repo] [branch]${C_RESET}            Open URL in browser"
  print -r -- "  ${C_GREEN}cd${C_RESET}       ${C_DIM}[repo] [branch]${C_RESET}            Print worktree path"
  print -r -- "  ${C_GREEN}switch${C_RESET}   ${C_DIM}<repo> [branch]${C_RESET}            cd + code + open in one"
  print -r -- "  ${C_GREEN}exec${C_RESET}     ${C_DIM}<repo> <branch> <cmd>${C_RESET}      Run command in worktree"
  print -r -- ""
  print -r -- "${C_BOLD}UTILITIES${C_RESET}"
  print -r -- "  ${C_GREEN}doctor${C_RESET}                              Check system requirements"
  print -r -- "  ${C_GREEN}health${C_RESET}   ${C_DIM}<repo>${C_RESET}                     Check repository health"
  print -r -- "  ${C_GREEN}report${C_RESET}   ${C_DIM}<repo> [--output <file>]${C_RESET}  Generate markdown status report"
  print -r -- "  ${C_GREEN}cleanup-herd${C_RESET}                        Remove orphaned Herd nginx configs"
  print -r -- "  ${C_GREEN}unlock${C_RESET}   ${C_DIM}[repo]${C_RESET}                    Remove stale git lock files"
  print -r -- ""
  print -r -- "${C_BOLD}FLAGS${C_RESET}"
  print -r -- "  ${C_YELLOW}-q, --quiet${C_RESET}          Suppress informational output"
  print -r -- "  ${C_YELLOW}-f, --force${C_RESET}          Skip confirmations / force protected branch removal"
  print -r -- "  ${C_YELLOW}--json${C_RESET}               Output in JSON format"
  print -r -- "  ${C_YELLOW}--pretty${C_RESET}             Pretty-print JSON output with colours"
  print -r -- "  ${C_YELLOW}--dry-run${C_RESET}            Preview actions without executing (wt add)"
  print -r -- "  ${C_YELLOW}-t, --template${C_RESET}       Apply template when creating worktree"
  print -r -- "  ${C_YELLOW}--delete-branch${C_RESET}      Delete branch when removing worktree"
  print -r -- "  ${C_YELLOW}--drop-db${C_RESET}            Drop database when removing worktree"
  print -r -- "  ${C_YELLOW}--no-backup${C_RESET}          Skip database backup when removing worktree"
  print -r -- "  ${C_YELLOW}-v, --version${C_RESET}        Show version"
  print -r -- ""
  print -r -- "${C_BOLD}EXAMPLES${C_RESET}"
  print -r -- "  ${C_DIM}# Set up a new project${C_RESET}"
  print -r -- "  wt clone git@github.com:org/myapp.git"
  print -r -- "  wt add myapp feature/login"
  print -r -- ""
  print -r -- "  ${C_DIM}# Navigate to worktree${C_RESET}"
  print -r -- "  cd \"\$(wt cd myapp feature/login)\""
  print -r -- ""
  print -r -- "  ${C_DIM}# Interactive selection (requires fzf)${C_RESET}"
  print -r -- "  wt code myapp              ${C_DIM}# opens fzf picker${C_RESET}"
  print -r -- ""
  print -r -- "  ${C_DIM}# Run command in worktree${C_RESET}"
  print -r -- "  wt exec myapp feature/login php artisan migrate"
  print -r -- ""
  print -r -- "  ${C_DIM}# Use template with dry-run preview${C_RESET}"
  print -r -- "  wt add myapp feature/api --template=backend --dry-run"
  print -r -- ""
  print -r -- "${C_BOLD}AVAILABLE TEMPLATES${C_RESET}"
  list_templates
  print -r -- ""
  print -r -- "  ${C_DIM}Run 'wt templates' for details or 'wt templates <name>' to view a template${C_RESET}"
  print -r -- ""
  print -r -- "${C_BOLD}ENVIRONMENT${C_RESET}"
  print -r -- "  ${C_YELLOW}HERD_ROOT${C_RESET}         Herd directory ${C_DIM}(default: \$HOME/Herd)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_BASE_DEFAULT${C_RESET}   Default base branch ${C_DIM}(default: origin/staging)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_EDITOR${C_RESET}         Editor command ${C_DIM}(default: cursor)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_CONFIG${C_RESET}         Config file path ${C_DIM}(default: ~/.wtrc)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_URL_SUBDOMAIN${C_RESET}  Optional URL subdomain ${C_DIM}(e.g., api -> api.feature.test)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_HOOKS_DIR${C_RESET}      Hooks directory ${C_DIM}(default: ~/.wt/hooks)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_HOST${C_RESET}        MySQL host ${C_DIM}(default: 127.0.0.1)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_USER${C_RESET}        MySQL user ${C_DIM}(default: root)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_PASSWORD${C_RESET}    MySQL password ${C_DIM}(default: empty)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_CREATE${C_RESET}      Auto-create database ${C_DIM}(default: true)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_BACKUP${C_RESET}      Backup database on remove ${C_DIM}(default: true)${C_RESET}"
  print -r -- "  ${C_YELLOW}WT_DB_BACKUP_DIR${C_RESET}  Backup directory ${C_DIM}(default: ~/Code/Project Support/...)${C_RESET}"
  print -r -- ""
  print -r -- "${C_BOLD}CONFIG FILE${C_RESET}"
  print -r -- "  Create ${C_CYAN}~/.wtrc${C_RESET} or ${C_CYAN}\$HERD_ROOT/.wtconfig${C_RESET} with:"
  print -r -- "    HERD_ROOT=/path/to/herd"
  print -r -- "    DEFAULT_BASE=origin/main"
  print -r -- "    DEFAULT_EDITOR=code"
  print -r -- "    WT_URL_SUBDOMAIN=api       ${C_DIM}# optional: api.feature.test${C_RESET}"
  print -r -- "    DB_USER=root"
  print -r -- "    DB_PASSWORD=secret"
  print -r -- "    DB_BACKUP_DIR=/path/to/backups"
  print -r -- ""
  print -r -- "${C_BOLD}HOOKS${C_RESET}"
  print -r -- "  Create executable scripts in ${C_CYAN}~/.wt/hooks/${C_RESET} to run custom commands:"
  print -r -- ""
  print -r -- "  ${C_GREEN}pre-add${C_RESET}      Run before worktree creation (can abort)"
  print -r -- "  ${C_GREEN}post-add${C_RESET}     Run after worktree creation"
  print -r -- "  ${C_GREEN}pre-rm${C_RESET}       Run before worktree removal (can abort)"
  print -r -- "  ${C_GREEN}post-rm${C_RESET}      Run after worktree removal"
  print -r -- "  ${C_GREEN}post-pull${C_RESET}    Run after wt pull succeeds"
  print -r -- "  ${C_GREEN}post-sync${C_RESET}    Run after wt sync succeeds"
  print -r -- ""
  print -r -- "  ${C_DIM}Available environment variables in hooks:${C_RESET}"
  print -r -- "    WT_REPO       Repository name"
  print -r -- "    WT_BRANCH     Branch name"
  print -r -- "    WT_PATH       Worktree path"
  print -r -- "    WT_URL        Application URL"
  print -r -- "    WT_DB_NAME    Database name"
  print -r -- ""
  print -r -- "  ${C_DIM}Example ~/.wt/hooks/post-add:${C_RESET}"
  print -r -- "    #!/bin/bash"
  print -r -- "    npm ci && npm run build"
  print -r -- "    php artisan migrate"
  print -r -- ""
  print -r -- "  ${C_DIM}Multiple hooks: Create ~/.wt/hooks/post-add.d/ with numbered scripts${C_RESET}"
  print -r -- "  ${C_DIM}Repo-specific: Create ~/.wt/hooks/post-add.d/<repo>/ for repo-only hooks${C_RESET}"
  print -r -- ""
}

# Parse global flags (can appear anywhere in command line)
parse_flags() {
  REMAINING_ARGS=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -q|--quiet) QUIET=true ;;
      -f|--force) FORCE=true ;;
      --json) JSON_OUTPUT=true ;;
      --delete-branch) DELETE_BRANCH=true ;;
      --drop-db) DROP_DB=true ;;
      --no-backup) NO_BACKUP=true ;;
      --dry-run) DRY_RUN=true ;;
      --pretty) PRETTY_JSON=true ;;
      --template=*)
        WT_TEMPLATE="${1#--template=}"
        if [[ -z "$WT_TEMPLATE" ]]; then
          setup_colors
          die "Template name cannot be empty"
        fi
        ;;
      -t)
        shift
        if [[ -z "${1:-}" || "$1" == -* ]]; then
          setup_colors
          die "Template name required after -t flag"
        fi
        WT_TEMPLATE="$1"
        ;;
      -v|--version) print -r -- "wt version $VERSION"; exit 0 ;;
      -h|--help|help) setup_colors; usage; exit 0 ;;
      -*) setup_colors; die "Unknown flag: $1" ;;
      *) REMAINING_ARGS+=("$1") ;;
    esac
    shift
  done
}

main() {
  load_config
  parse_flags "$@"
  setup_colors

  set -- "${REMAINING_ARGS[@]}"

  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    add)      cmd_add "$@" ;;
    rm)       cmd_rm "$@" ;;
    ls)       cmd_ls "$@" ;;
    status)   cmd_status "$@" ;;
    pull)     cmd_pull "$@" ;;
    pull-all) cmd_pull_all "$@" ;;
    sync)     cmd_sync "$@" ;;
    clone)    cmd_clone "$@" ;;
    code)     cmd_code "$@" ;;
    open)     cmd_open "$@" ;;
    cd)       cmd_cd "$@" ;;
    exec)     cmd_exec "$@" ;;
    prune)    cmd_prune "$@" ;;
    repos)    cmd_repos "$@" ;;
    templates) cmd_templates "$@" ;;
    doctor)   cmd_doctor "$@" ;;
    cleanup-herd) cmd_cleanup_herd "$@" ;;
    unlock)   cmd_unlock "$@" ;;
    fresh)    cmd_fresh "$@" ;;
    switch)   cmd_switch "$@" ;;
    migrate)  cmd_migrate "$@" ;;
    tinker)   cmd_tinker "$@" ;;
    log)      cmd_log "$@" ;;
    diff)     cmd_diff "$@" ;;
    report)   cmd_report "$@" ;;
    health)   cmd_health "$@" ;;
    "")       usage ;;
    *)        die "Unknown command: $cmd (try: wt --help)" ;;
  esac
}

main "$@"
